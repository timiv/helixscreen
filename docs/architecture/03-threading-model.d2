# HelixScreen Threading Model
direction: right

title: {
  label: Threading Model
  near: top-center
  shape: text
  style.font-size: 28
  style.bold: true
}

main: {
  label: "MAIN THREAD (UI + LVGL)"
  style.fill: "#0f3460"
  style.font-color: "#fff"

  loop: {
    label: "Main Loop: lv_timer_handler()"
    style.fill: "#16213e"

    step1: "1. UpdateQueue::process_pending()\nDrain queued lambdas\n⚡ HIGHEST PRIORITY" {
      style.fill: "#ffd166"
      style.font-color: "#000"
      style.bold: true
    }
    step2: "2. LVGL timers\nInput polling, animations" { shape: rectangle }
    step3: "3. process_notifications()\nDequeue Moonraker JSON\n→ PrinterState::update()" { shape: rectangle }
    step4: "4. lv_refr_now()\nRender dirty regions to framebuffer" {
      style.fill: "#06d6a0"
      style.font-color: "#000"
    }

    step1 -> step2 -> step3 -> step4
  }

  owns: {
    label: "Main Thread EXCLUSIVELY Owns"
    style.fill: "#16213e"
    style.stroke: "#00b4d8"

    a: "All LVGL subjects (lv_subject_set_*)" { shape: rectangle }
    b: "All LVGL widgets (lv_obj_*)" { shape: rectangle }
    c: "All observer callbacks" { shape: rectangle }
    d: "Theme + layout changes" { shape: rectangle }
  }
}

bridge: {
  label: "Thread-Safe Bridges"
  style.fill: "#ffd166"
  style.font-color: "#000"

  uq: {
    label: "UpdateQueue"
    style.fill: "#f4a261"

    q: "std::queue<std::function<void()>>\n+ std::mutex" { shape: queue }
    api: "helix::ui::queue_update(λ)\nhelix::ui::async_call(λ)" { shape: rectangle }
  }

  nq: {
    label: "Notification Queue"
    style.fill: "#f4a261"

    q: "std::queue<json>\n+ std::mutex" { shape: queue }
  }

  atoms: "Atomic Flags\nstd::atomic<bool>\n(connection state, etc.)" { shape: rectangle }
}

libhv: {
  label: "LIBHV THREAD (Network I/O)"
  style.fill: "#4e4376"
  style.font-color: "#fff"

  el: "libhv Event Loop" { shape: hexagon }
  ws: "WebSocket Connection\nMoonrakerClient" { shape: diamond }
  jrpc: "JSON-RPC 2.0 Parser" { shape: rectangle }
  recon: "Auto-reconnect\n(exponential backoff)" { shape: rectangle }
  http: "HTTP transfers\n(files, thumbnails)" { shape: rectangle }

  el -> ws
  ws -> jrpc
  el -> recon
  el -> http

  forbidden: {
    label: |md
      **FORBIDDEN from this thread:**
      `lv_subject_set_*()`
      `lv_obj_*()`
      Any direct LVGL call
    |
    shape: text
    style.font-color: "#ef476f"
    style.bold: true
    style.font-size: 14
  }
}

util: {
  label: "UTILITY THREADS"
  style.fill: "#1b4332"
  style.font-color: "#fff"

  uc: "UpdateChecker\nGitHub releases polling\n(1hr rate limit)" { shape: rectangle }
  tlm: "TelemetryManager\nBatch POST analytics" { shape: rectangle }
  cr: "CrashReporter\nAsync dump collection" { shape: rectangle }
}

# Connections
libhv.jrpc -> bridge.nq.q: "push notification" {
  style.stroke: "#e94560"
  style.stroke-width: 2
}
libhv.ws -> bridge.uq.api: "queue_update(λ)" {
  style.stroke: "#ffd166"
  style.stroke-width: 2
}

util.uc -> bridge.uq.api: "queue_update(λ)" { style.stroke: "#ffd166" }
util.tlm -> bridge.atoms: "atomic flags"
util.cr -> bridge.uq.api: "queue_update(λ)" { style.stroke: "#ffd166" }

bridge.uq.q -> main.loop.step1: "drain on main thread" {
  style.stroke: "#ffd166"
  style.stroke-width: 3
}
bridge.nq.q -> main.loop.step3: "drain on main thread" {
  style.stroke: "#e94560"
  style.stroke-width: 2
}

# Safety rules
rules: {
  label: |md
    ## Safety Rules
    1. **NEVER** `lv_subject_set_*()` from background thread → CRASH
    2. **ALWAYS** `queue_update(λ)` from non-main threads
    3. **NEVER** block main thread (no sleep, no sync HTTP)
    4. UpdateQueue runs **FIRST** → subjects current before render
    5. `observe_int_sync` defers via `queue_update()` (issue #82 fix)
  |
  shape: text
  style.font-size: 14
  near: bottom-center
}
