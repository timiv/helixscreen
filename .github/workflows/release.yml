name: Release

on:
  push:
    tags:
      - 'v*'  # Triggers on v1.0.0, v1.2.3-beta, etc.

# Ensure only one release workflow runs at a time
concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  # ============================================================================
  # Validate shell scripts before building release packages
  # ============================================================================
  validate-shell:
    name: Validate Shell Scripts
    runs-on: ubuntu-22.04
    timeout-minutes: 5

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Install bats
      run: sudo apt-get update -qq && sudo apt-get install -y bats

    - name: Verify bundled installers are up-to-date
      run: |
        bash scripts/bundle-installer.sh -o /tmp/install-regen.sh
        bash scripts/bundle-uninstaller.sh -o /tmp/uninstall-regen.sh
        diff scripts/install.sh /tmp/install-regen.sh || {
          echo "::error::scripts/install.sh is stale — run: bash scripts/bundle-installer.sh -o scripts/install.sh"
          exit 1
        }
        diff scripts/uninstall.sh /tmp/uninstall-regen.sh || {
          echo "::error::scripts/uninstall.sh is stale — run: bash scripts/bundle-uninstaller.sh -o scripts/uninstall.sh"
          exit 1
        }

    - name: Run shell tests
      run: make test-shell

  # ============================================================================
  # Build embedded platform binaries using Docker cross-compilation
  # ============================================================================
  build-platforms:
    name: Build (${{ matrix.display_name }})
    needs: [validate-shell]
    runs-on: ubuntu-22.04
    timeout-minutes: 60
    strategy:
      fail-fast: false
      matrix:
        platform: [pi, pi32, ad5m, cc1, k1, k2]
        include:
          - platform: pi
            display_name: "Raspberry Pi"
          - platform: pi32
            display_name: "Raspberry Pi 32-bit"
          - platform: ad5m
            display_name: "Adventurer 5M"
          - platform: cc1
            display_name: "Elegoo Centauri Carbon 1"
          - platform: k1
            display_name: "Creality K1 Series"
          - platform: k2
            display_name: "Creality K2 Series"

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Cache Docker layers
      uses: actions/cache@v4
      with:
        path: /tmp/.buildx-cache
        key: buildx-${{ matrix.platform }}-${{ hashFiles(format('docker/Dockerfile.{0}', matrix.platform)) }}
        restore-keys: |
          buildx-${{ matrix.platform }}-

    - name: Cache ccache
      uses: actions/cache@v4
      with:
        path: /tmp/.ccache-${{ matrix.platform }}
        key: ccache-release-${{ matrix.platform }}-${{ github.sha }}
        restore-keys: |
          ccache-release-${{ matrix.platform }}-

    - name: Configure ccache
      run: |
        mkdir -p /tmp/.ccache-${{ matrix.platform }}
        printf 'max_size = 300M\ncompression = true\n' > /tmp/.ccache-${{ matrix.platform }}/ccache.conf

    - name: Build ${{ matrix.platform }} toolchain image
      run: |
        docker buildx build \
          --cache-from type=local,src=/tmp/.buildx-cache \
          --cache-to type=local,dest=/tmp/.buildx-cache-new,mode=max \
          --load \
          -t helixscreen/toolchain-${{ matrix.platform }} \
          -f docker/Dockerfile.${{ matrix.platform }} \
          docker/

    - name: Cross-compile for ${{ matrix.display_name }}
      run: |
        docker run --rm \
          -v "${{ github.workspace }}":/src \
          -v /tmp/.ccache-${{ matrix.platform }}:/root/.cache/ccache \
          -w /src \
          helixscreen/toolchain-${{ matrix.platform }} \
          make PLATFORM_TARGET=${{ matrix.platform }} SKIP_OPTIONAL_DEPS=1 -j$(nproc)

    - name: Show ccache stats
      run: |
        docker run --rm \
          -v /tmp/.ccache-${{ matrix.platform }}:/root/.cache/ccache \
          helixscreen/toolchain-${{ matrix.platform }} \
          ccache -s

    # Symbol extraction and stripping are handled by the 'all' target
    # (all → strip → symbols → nm, then strip). No separate steps needed.

    - name: Fix build directory ownership
      run: sudo chown -R $(id -u):$(id -g) build/

    - name: Generate pre-rendered images
      run: make venv-setup && make gen-all-images

    - name: Package ${{ matrix.platform }} release
      run: make release-${{ matrix.platform }}

    - name: Upload ${{ matrix.platform }} artifact
      uses: actions/upload-artifact@v4
      with:
        name: release-${{ matrix.platform }}
        path: |
          releases/helixscreen-${{ matrix.platform }}-*.tar.gz
          releases/helixscreen-${{ matrix.platform }}.zip
        retention-days: 7

    - name: Upload symbol map artifact
      uses: actions/upload-artifact@v4
      with:
        name: symbols-${{ matrix.platform }}
        path: |
          build/${{ matrix.platform }}/bin/helix-screen.sym
          build/${{ matrix.platform }}/bin/helix-screen.debug
        retention-days: 30

    - name: Move cache
      run: |
        rm -rf /tmp/.buildx-cache
        mv /tmp/.buildx-cache-new /tmp/.buildx-cache || true

  # ============================================================================
  # Build Android APKs (runs in parallel with embedded platform builds)
  # ============================================================================
  build-android:
    name: Build (Android)
    needs: [validate-shell]
    runs-on: ubuntu-22.04
    timeout-minutes: 90

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        distribution: temurin
        java-version: 17

    - name: Install Android NDK
      run: |
        yes | sudo ${ANDROID_HOME}/cmdline-tools/latest/bin/sdkmanager --install "ndk;29.0.14206865" || true

    - name: Set up ccache
      uses: hendrikmuhs/ccache-action@v1.2
      with:
        key: android-ndk-${{ runner.os }}
        max-size: 500M

    - name: Cache Gradle
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: gradle-${{ hashFiles('android/**/*.gradle', 'android/gradle/wrapper/gradle-wrapper.properties') }}
        restore-keys: |
          gradle-

    - name: Apply submodule patches
      run: make apply-patches

    - name: Build Android APKs (release)
      working-directory: android
      env:
        ANDROID_KEYSTORE_PATH: ${{ secrets.ANDROID_KEYSTORE_PATH }}
        ANDROID_KEYSTORE_PASSWORD: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
        ANDROID_KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
        ANDROID_KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}
      run: ./gradlew assembleRelease -PuseCcache

    - name: Extract version
      id: version
      run: |
        VERSION="${GITHUB_REF_NAME#v}"
        echo "version=$VERSION" >> $GITHUB_OUTPUT

    - name: Rename APKs
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        APK_DIR="android/app/build/outputs/apk/release"
        mkdir -p release-apks

        # Rename ABI-split APKs to our naming convention
        for apk in "$APK_DIR"/*.apk; do
          filename=$(basename "$apk")
          case "$filename" in
            *arm64-v8a*) cp "$apk" "release-apks/helixscreen-android-arm64-v${VERSION}.apk" ;;
            *x86_64*)    cp "$apk" "release-apks/helixscreen-android-x86_64-v${VERSION}.apk" ;;
            *universal*) cp "$apk" "release-apks/helixscreen-android-universal-v${VERSION}.apk" ;;
          esac
        done

        echo "Android APKs:"
        ls -lh release-apks/

    - name: Upload Android artifacts
      uses: actions/upload-artifact@v4
      with:
        name: release-android
        path: release-apks/*.apk
        retention-days: 7

  # ============================================================================
  # Create GitHub Release with all artifacts
  # ============================================================================
  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [build-platforms]
    permissions:
      contents: write  # Required to create releases

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts

    - name: Prepare release files
      run: |
        mkdir -p release-files
        find artifacts -name '*.tar.gz' -exec mv {} release-files/ \;
        find artifacts -name '*.zip' -exec mv {} release-files/ \;
        find artifacts -name '*.apk' -exec mv {} release-files/ \;
        # Include install.sh so users can download it directly from the release
        cp scripts/install.sh release-files/
        echo "Release files:"
        ls -lh release-files/

    - name: Extract version from tag
      id: version
      run: |
        # Tag name is the full version with 'v' prefix (e.g., v1.2.3)
        # Used for release title and filename references
        VERSION="${GITHUB_REF_NAME}"
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Version: $VERSION"

    - name: Generate release notes
      id: notes
      run: |
        # Try to get annotated tag message, fall back to auto-generated notes
        TAG_MESSAGE=$(git tag -l --format='%(contents)' "$GITHUB_REF_NAME" 2>/dev/null | head -50)

        if [ -n "$TAG_MESSAGE" ] && [ "$TAG_MESSAGE" != "" ]; then
          echo "Using tag annotation for release notes"
          echo "$TAG_MESSAGE" > release-notes.md
        else
          echo "Generating release notes from commits"
          cat > release-notes.md << 'EOF'
        ## What's New

        See the [commit history](https://github.com/${{ github.repository }}/commits/${{ github.ref_name }}) for details.

        ## Installation

        ### Raspberry Pi (Mainsail OS - 64-bit)
        ```bash
        # Download and extract
        wget https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/helixscreen-pi-${{ steps.version.outputs.version }}.tar.gz
        tar -xzf helixscreen-pi-${{ steps.version.outputs.version }}.tar.gz
        cd helixscreen

        # Run
        ./helix-screen
        ```

        ### Raspberry Pi (Mainsail OS - 32-bit)
        ```bash
        # Download and extract
        wget https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/helixscreen-pi32-${{ steps.version.outputs.version }}.tar.gz
        tar -xzf helixscreen-pi32-${{ steps.version.outputs.version }}.tar.gz
        cd helixscreen

        # Run
        ./helix-screen
        ```

        ### Flashforge Adventurer 5M
        ```bash
        # Download and extract
        wget https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/helixscreen-ad5m-${{ steps.version.outputs.version }}.tar.gz
        tar -xzf helixscreen-ad5m-${{ steps.version.outputs.version }}.tar.gz
        cd helixscreen

        # Run
        ./helix-screen
        ```

        ### Creality K1 Series (Simple AF)
        ```bash
        # Download and extract
        wget https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/helixscreen-k1-${{ steps.version.outputs.version }}.tar.gz
        tar -xzf helixscreen-k1-${{ steps.version.outputs.version }}.tar.gz
        cd helixscreen

        # Run
        ./helix-screen
        ```

        ### Creality K2 Series
        ```bash
        # Download and extract
        wget https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/helixscreen-k2-${{ steps.version.outputs.version }}.tar.gz
        tar -xzf helixscreen-k2-${{ steps.version.outputs.version }}.tar.gz
        cd helixscreen

        # Run
        ./helix-screen
        ```

        ### Android (Experimental)
        Download the APK for your device architecture:
        - **arm64**: `helixscreen-android-arm64-${{ steps.version.outputs.version }}.apk` (most Android phones/tablets)
        - **x86_64**: `helixscreen-android-x86_64-${{ steps.version.outputs.version }}.apk` (emulators, Chromebooks)
        - **universal**: `helixscreen-android-universal-${{ steps.version.outputs.version }}.apk` (all architectures)

        Sideload via `adb install` or download directly on device.

        ## Checksums

        ```
        $(cd release-files && sha256sum *.tar.gz *.zip *.apk 2>/dev/null)
        ```
        EOF
        fi

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        name: ${{ steps.version.outputs.version }}
        body_path: release-notes.md
        draft: false
        prerelease: ${{ contains(github.ref_name, '-') }}  # v1.0.0-beta -> prerelease
        files: |
          release-files/*.tar.gz
          release-files/*.zip
          release-files/*.apk
          release-files/install.sh
        fail_on_unmatched_files: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Notify Discord
      if: success()
      continue-on-error: true
      env:
        DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
      run: |
        [ -z "$DISCORD_WEBHOOK_URL" ] && { echo "No webhook configured, skipping"; exit 0; }

        VERSION="${GITHUB_REF_NAME}"
        RELEASE_URL="https://github.com/${{ github.repository }}/releases/tag/${VERSION}"

        # Extract changelog entry from CHANGELOG.md
        PLAIN_VERSION="${VERSION#v}"
        CHANGELOG=""
        if [ -f CHANGELOG.md ]; then
          CHANGELOG=$(awk -v ver="$PLAIN_VERSION" '
            /^## \[/ {
              if (found) exit
              if (index($0, "[" ver "]")) found=1
              next
            }
            found { print }
          ' CHANGELOG.md)
        fi

        # Truncate to fit Discord embed limit (4096 chars) with room for wrapper
        if [ ${#CHANGELOG} -gt 3800 ]; then
          CHANGELOG="${CHANGELOG:0:3800}..."
        fi

        # Escape for JSON: backslashes, double quotes, newlines
        CHANGELOG_JSON=$(printf '%s' "$CHANGELOG" | python3 -c 'import json,sys; print(json.dumps(sys.stdin.read()))')

        # Determine embed color: green for stable, yellow for prerelease
        if [[ "$VERSION" == *-* ]]; then
          COLOR=16761095  # #FFD700 gold
          TITLE="HelixScreen ${VERSION} (Pre-release)"
        else
          COLOR=3066993   # #2ECC71 green
          TITLE="HelixScreen ${VERSION} Released"
        fi

        # Build and send Discord webhook payload
        curl -s -o /dev/null -w "%{http_code}" \
          -H "Content-Type: application/json" \
          -d "{
            \"embeds\": [{
              \"title\": \"${TITLE}\",
              \"url\": \"${RELEASE_URL}\",
              \"description\": ${CHANGELOG_JSON},
              \"color\": ${COLOR},
              \"footer\": {
                \"text\": \"GitHub Actions\"
              },
              \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
            }]
          }" \
          "$DISCORD_WEBHOOK_URL"

  # ============================================================================
  # Upload release artifacts to R2 for auto-update
  # ============================================================================
  upload-r2:
    name: Upload to R2
    runs-on: ubuntu-latest
    needs: [release]
    continue-on-error: true
    # Run for all tagged releases (including prereleases)
    if: startsWith(github.ref, 'refs/tags/v')

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts

    - name: Flatten release files
      run: |
        mkdir -p release-files
        find artifacts -name '*.tar.gz' -exec mv {} release-files/ \;
        find artifacts -name '*.zip' -exec mv {} release-files/ \;
        echo "Release files:"
        ls -lh release-files/

    - name: Flatten symbol files
      run: |
        mkdir -p symbol-files
        for dir in artifacts/symbols-*/; do
          platform=$(basename "$dir" | sed 's/symbols-//')
          if [ -f "${dir}helix-screen.sym" ]; then
            cp "${dir}helix-screen.sym" "symbol-files/${platform}.sym"
          fi
          if [ -f "${dir}helix-screen.debug" ]; then
            cp "${dir}helix-screen.debug" "symbol-files/${platform}.debug"
          fi
        done
        echo "Symbol files:"
        ls -lh symbol-files/ || echo "No symbol files found"

    - name: Extract version from tag
      id: version
      run: |
        # Strip 'v' prefix: v0.9.5 -> 0.9.5
        VERSION="${GITHUB_REF_NAME#v}"
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "tag=$GITHUB_REF_NAME" >> $GITHUB_OUTPUT
        echo "Version: $VERSION (tag: $GITHUB_REF_NAME)"

    - name: Extract changelog for version
      id: notes
      run: |
        VERSION="${{ steps.version.outputs.version }}"

        # Extract the section for this version from CHANGELOG.md
        # Matches from "## [VERSION]" to the next "## [" or end of file
        if [ -f CHANGELOG.md ]; then
          NOTES=$(awk -v ver="$VERSION" '
            /^## \[/ {
              if (found) exit
              if (index($0, "[" ver "]")) found=1
              next
            }
            found { print }
          ' CHANGELOG.md)
        fi

        if [ -z "$NOTES" ]; then
          NOTES="Release $GITHUB_REF_NAME"
        fi

        # Use delimiter for multiline output
        {
          echo "notes<<CHANGELOG_EOF"
          echo "$NOTES"
          echo "CHANGELOG_EOF"
        } >> $GITHUB_OUTPUT

    - name: Validate R2 configuration
      run: |
        if [ -z "${{ vars.R2_PUBLIC_URL }}" ]; then
          echo "::error::R2_PUBLIC_URL repository variable is not configured"
          exit 1
        fi

    - name: Determine upload channels
      id: channels
      run: |
        TAG="${GITHUB_REF_NAME}"
        if [[ "$TAG" == *-* ]]; then
          # Prerelease tag (v1.0.0-beta, v1.0.0-rc.1) -> beta + dev
          CHANNELS="beta dev"
        else
          # Stable tag (v0.9.5) -> stable + dev
          CHANNELS="stable dev"
        fi
        echo "channels=$CHANNELS" >> $GITHUB_OUTPUT
        echo "Upload channels: $CHANNELS"

    - name: Generate manifests and upload to R2
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
        R2_ENDPOINT: https://${{ secrets.R2_ACCOUNT_ID }}.r2.cloudflarestorage.com
        RELEASE_NOTES: ${{ steps.notes.outputs.notes }}
        RELEASE_VERSION: ${{ steps.version.outputs.version }}
        RELEASE_TAG: ${{ steps.version.outputs.tag }}
        R2_BUCKET: ${{ vars.R2_BUCKET_NAME || 'helixscreen-releases' }}
        R2_PUBLIC_URL: ${{ vars.R2_PUBLIC_URL }}
        UPLOAD_CHANNELS: ${{ steps.channels.outputs.channels }}
      run: |
        chmod +x scripts/generate-manifest.sh

        for CHANNEL in $UPLOAD_CHANNELS; do
          echo "=== Uploading to ${CHANNEL} channel ==="

          # Generate channel-specific manifest
          scripts/generate-manifest.sh \
            --version "$RELEASE_VERSION" \
            --tag "$RELEASE_TAG" \
            --notes "$RELEASE_NOTES" \
            --dir release-files \
            --base-url "${R2_PUBLIC_URL}/${CHANNEL}" \
            --output "release-files/manifest-${CHANNEL}.json"

          echo "Generated manifest for ${CHANNEL}:"
          cat "release-files/manifest-${CHANNEL}.json" | jq .

          # Upload all tarballs
          for tarball in release-files/*.tar.gz release-files/*.zip; do
            filename=$(basename "$tarball")
            echo "Uploading ${CHANNEL}/${filename}..."
            aws s3 cp "$tarball" "s3://${R2_BUCKET}/${CHANNEL}/${filename}" \
              --endpoint-url "$R2_ENDPOINT"
          done

          # Upload manifest
          echo "Uploading ${CHANNEL}/manifest.json..."
          aws s3 cp "release-files/manifest-${CHANNEL}.json" \
            "s3://${R2_BUCKET}/${CHANNEL}/manifest.json" \
            --endpoint-url "$R2_ENDPOINT" \
            --content-type "application/json"

          echo "=== ${CHANNEL} upload complete ==="
        done

        # Upload symbol maps and debug info (version-keyed, not channel-specific)
        echo "=== Uploading symbol maps ==="
        for symfile in symbol-files/*.sym; do
          [ -f "$symfile" ] || continue
          filename=$(basename "$symfile")
          platform="${filename%.sym}"
          echo "Uploading symbols/v${RELEASE_VERSION}/${platform}.sym..."
          aws s3 cp "$symfile" \
            "s3://${R2_BUCKET}/symbols/v${RELEASE_VERSION}/${platform}.sym" \
            --endpoint-url "$R2_ENDPOINT" \
            --content-type "text/plain"
        done

        echo "=== Uploading debug info ==="
        for dbgfile in symbol-files/*.debug; do
          [ -f "$dbgfile" ] || continue
          filename=$(basename "$dbgfile")
          platform="${filename%.debug}"
          echo "Uploading symbols/v${RELEASE_VERSION}/${platform}.debug..."
          aws s3 cp "$dbgfile" \
            "s3://${R2_BUCKET}/symbols/v${RELEASE_VERSION}/${platform}.debug" \
            --endpoint-url "$R2_ENDPOINT" \
            --content-type "application/octet-stream"
        done
        echo "=== Symbol upload complete ==="

        echo "All uploads complete!"
        for CHANNEL in $UPLOAD_CHANNELS; do
          echo "  ${CHANNEL}: ${R2_PUBLIC_URL}/${CHANNEL}/manifest.json"
        done

    - name: Clean up old releases (retain 10 most recent)
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
        R2_ENDPOINT: https://${{ secrets.R2_ACCOUNT_ID }}.r2.cloudflarestorage.com
        R2_BUCKET: ${{ vars.R2_BUCKET_NAME || 'helixscreen-releases' }}
        UPLOAD_CHANNELS: ${{ steps.channels.outputs.channels }}
        RETAIN_COUNT: 10
      run: |
        # Sort versions using semver-aware sort (numeric on each dotted component)
        semver_sort() {
          sort -t. -k1,1n -k2,2n -k3,3n
        }

        for CHANNEL in $UPLOAD_CHANNELS; do
          echo "=== Pruning old releases from ${CHANNEL} ==="

          # List all .tar.gz files in channel, extract unique versions
          VERSIONS=$(aws s3 ls "s3://${R2_BUCKET}/${CHANNEL}/" \
            --endpoint-url "$R2_ENDPOINT" \
            | grep -oP 'helixscreen-\w+-v\K[0-9]+\.[0-9]+\.[0-9]+(?:-[a-zA-Z0-9.]+)?(?=\.tar\.gz)' \
            | sort -u \
            | semver_sort)

          VERSION_COUNT=$(echo "$VERSIONS" | grep -c . || true)
          echo "Found ${VERSION_COUNT} versions in ${CHANNEL}"

          if [ "$VERSION_COUNT" -le "$RETAIN_COUNT" ]; then
            echo "Within retention limit, nothing to prune"
            continue
          fi

          # Get versions to delete (all but the most recent N)
          DELETE_VERSIONS=$(echo "$VERSIONS" | head -n -${RETAIN_COUNT})
          DELETE_COUNT=$(echo "$DELETE_VERSIONS" | grep -c . || true)
          echo "Pruning ${DELETE_COUNT} old versions: $(echo $DELETE_VERSIONS | tr '\n' ' ')"

          for VERSION in $DELETE_VERSIONS; do
            # Delete all files matching this version in the channel
            aws s3 ls "s3://${R2_BUCKET}/${CHANNEL}/" \
              --endpoint-url "$R2_ENDPOINT" \
              | awk '{print $4}' \
              | grep -- "-v${VERSION}\." \
              | while read -r filename; do
                echo "  Deleting ${CHANNEL}/${filename}"
                aws s3 rm "s3://${R2_BUCKET}/${CHANNEL}/${filename}" \
                  --endpoint-url "$R2_ENDPOINT"
              done
          done

          echo "=== ${CHANNEL} pruning complete ==="
        done

        # Prune old symbol maps
        echo "=== Pruning old symbol maps ==="
        SYM_VERSIONS=$(aws s3 ls "s3://${R2_BUCKET}/symbols/" \
          --endpoint-url "$R2_ENDPOINT" \
          | grep -oP 'PRE v\K[0-9]+\.[0-9]+\.[0-9]+(?:[-.][a-zA-Z0-9.]+)?' \
          | sort -u \
          | semver_sort)

        SYM_COUNT=$(echo "$SYM_VERSIONS" | grep -c . || true)
        echo "Found ${SYM_COUNT} symbol versions"

        if [ "$SYM_COUNT" -gt "$RETAIN_COUNT" ]; then
          DELETE_SYM_VERSIONS=$(echo "$SYM_VERSIONS" | head -n -${RETAIN_COUNT})
          DELETE_SYM_COUNT=$(echo "$DELETE_SYM_VERSIONS" | grep -c . || true)
          echo "Pruning ${DELETE_SYM_COUNT} old symbol versions"

          for VERSION in $DELETE_SYM_VERSIONS; do
            echo "  Deleting symbols/v${VERSION}/"
            aws s3 rm "s3://${R2_BUCKET}/symbols/v${VERSION}/" \
              --endpoint-url "$R2_ENDPOINT" \
              --recursive
          done
        else
          echo "Within retention limit, nothing to prune"
        fi
        echo "=== Symbol pruning complete ==="