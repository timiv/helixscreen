#!/bin/sh
# SPDX-License-Identifier: GPL-3.0-or-later
#
# SysV init script for HelixScreen
# For use on systems without systemd (e.g., FlashForge AD5M with BusyBox init)
#
# Installation varies by firmware:
#   Forge-X:      /etc/init.d/S90helixscreen -> /opt/helixscreen
#   Klipper Mod:  /etc/init.d/S80helixscreen -> /root/printer_software/helixscreen
#
# The install.sh script automatically selects the correct paths.
# DAEMON_DIR below is updated by the installer to match the install location.
#
# Usage:
#   /etc/init.d/S*helixscreen start|stop|restart|status
#
# Note: S80/S90 prefix ensures we start after network and Moonraker

NAME="helixscreen"
DESC="HelixScreen 3D Printer Touch UI"
DAEMON_DIR="/opt/helixscreen"  # Updated by installer for different firmware
DAEMON="${DAEMON_DIR}/bin/helix-screen"
SPLASH="${DAEMON_DIR}/bin/helix-splash"
WATCHDOG="${DAEMON_DIR}/bin/helix-watchdog"
LAUNCHER="${DAEMON_DIR}/bin/helix-launcher.sh"
PIDFILE="/var/run/${NAME}.pid"
LOGFILE="/tmp/helixscreen.log"

# Override asset directory if ui_xml/assets/config are not under DAEMON_DIR
# Export so helix-screen picks it up at startup
# HELIX_DATA_DIR="/mnt/data/helixscreen"
# export HELIX_DATA_DIR

# ForgeX backlight control paths (AD5M with ForgeX firmware)
FORGEX_BACKLIGHT="/root/printer_data/py/backlight.py"

# Check if binary exists
[ -x "$DAEMON" ] || exit 0

# Known competing screen UIs to stop
COMPETING_UIS="guppyscreen GuppyScreen KlipperScreen klipperscreen featherscreen FeatherScreen"

# Stop competing screen UIs
stop_competing_uis() {
    # Stop stock FlashForge firmware UI (AD5M/Adventurer 5M)
    # ffstartup-arm is the startup manager that launches firmwareExe (the stock Qt UI)
    if [ -f /opt/PROGRAM/ffstartup-arm ]; then
        echo "Stopping stock FlashForge UI..."
        if command -v killall >/dev/null 2>&1; then
            killall firmwareExe 2>/dev/null || true
            killall ffstartup-arm 2>/dev/null || true
        else
            for pid in $(pidof firmwareExe 2>/dev/null); do
                kill "$pid" 2>/dev/null || true
            done
            for pid in $(pidof ffstartup-arm 2>/dev/null); do
                kill "$pid" 2>/dev/null || true
            done
        fi
    fi

    # On Klipper Mod, stop Xorg first (required for framebuffer access)
    # Xorg takes over /dev/fb0 layer, preventing direct framebuffer rendering
    if [ -x "/etc/init.d/S40xorg" ]; then
        echo "Stopping Xorg (Klipper Mod)..."
        /etc/init.d/S40xorg stop 2>/dev/null || true
        # Kill any remaining Xorg processes
        if command -v killall >/dev/null 2>&1; then
            killall Xorg 2>/dev/null || true
            killall X 2>/dev/null || true
        else
            for pid in $(pidof Xorg 2>/dev/null) $(pidof X 2>/dev/null); do
                kill "$pid" 2>/dev/null || true
            done
        fi
    fi

    for ui in $COMPETING_UIS; do
        # Check init.d scripts
        for initscript in /etc/init.d/S*${ui}* /opt/config/mod/.root/S*${ui}*; do
            if [ -x "$initscript" ] 2>/dev/null; then
                echo "Stopping competing UI: $initscript"
                "$initscript" stop 2>/dev/null || true
            fi
        done
        # Kill any remaining processes (BusyBox compatible - no pkill)
        if command -v killall >/dev/null 2>&1; then
            killall "$ui" 2>/dev/null || true
        else
            # BusyBox fallback - use pidof + kill
            for pid in $(pidof "$ui" 2>/dev/null); do
                kill "$pid" 2>/dev/null || true
            done
        fi
    done

    # Kill python-based KlipperScreen (runs as python3 process)
    if command -v killall >/dev/null 2>&1; then
        # Match python processes running screen.py (KlipperScreen entry point)
        for pid in $(ps 2>/dev/null | grep -E 'python.*screen\.py' | grep -v grep | awk '{print $1}'); do
            echo "Killing KlipperScreen python process (PID $pid)"
            kill "$pid" 2>/dev/null || true
        done
    fi

    # Brief pause to let processes exit
    sleep 1
}

# ForgeX chroot location (AD5M with ForgeX firmware)
FORGEX_CHROOT="/data/.mod/.forge-x"

# Enable display backlight (for ForgeX firmware on AD5M)
# ForgeX may leave the backlight off when display mode is STOCK,
# so we explicitly enable it before starting HelixScreen.
# NOTE: FORGEX_BACKLIGHT is the path INSIDE the chroot, not the host path!
enable_backlight() {
    # ForgeX stores backlight.py inside a chroot environment
    # Must run via chroot for the ioctl to work
    # Check the FULL path (chroot + script) for existence
    local full_backlight_path="${FORGEX_CHROOT}${FORGEX_BACKLIGHT}"
    if [ -d "$FORGEX_CHROOT" ] && [ -x "$full_backlight_path" ]; then
        echo "Enabling backlight via ForgeX chroot..."
        /usr/sbin/chroot "$FORGEX_CHROOT" "$FORGEX_BACKLIGHT" 100 2>/dev/null || true
        return 0
    fi

    # Log if we couldn't enable backlight (helps debug boot issues)
    echo "Warning: Could not enable backlight (chroot=$FORGEX_CHROOT, script=$full_backlight_path)"
    return 1
}

# Start splash screen (if available)
# Returns the --splash-pid argument on stdout (for capture by caller)
# Status messages go to stderr to avoid polluting the return value
start_splash() {
    if [ -x "$SPLASH" ]; then
        echo "Starting splash screen..." >&2
        # Redirect splash output to /dev/null to prevent any contamination of captured stdout
        # Splash auto-detects resolution from display hardware
        "$SPLASH" >/dev/null 2>&1 &
        SPLASH_PID=$!
        echo "$SPLASH_PID" > /var/run/helix-splash.pid
        echo "--splash-pid=$SPLASH_PID"
    fi
}

# Stop splash screen
stop_splash() {
    if [ -f /var/run/helix-splash.pid ]; then
        SPLASH_PID=$(cat /var/run/helix-splash.pid)
        kill "$SPLASH_PID" 2>/dev/null || true
        rm -f /var/run/helix-splash.pid
    fi
}

start() {
    echo "Starting $DESC..."

    # Create flag file so ForgeX S99root skips screen output
    touch /tmp/helixscreen_active

    # Stop any competing UIs first
    stop_competing_uis

    # Enable backlight (ForgeX may leave it off)
    enable_backlight

    # Check if already running
    if [ -f "$PIDFILE" ]; then
        PID=$(cat "$PIDFILE")
        if kill -0 "$PID" 2>/dev/null; then
            echo "$NAME is already running (PID $PID)"
            return 0
        fi
        rm -f "$PIDFILE"
    fi

    cd "$DAEMON_DIR"

    # Start splash screen early (before launcher) so it's visible during load
    # Set HELIX_NO_SPLASH=1 to disable splash (for debugging backlight issues)
    # Splash auto-detects resolution from display hardware
    EARLY_SPLASH_PID=""
    if [ -x "$SPLASH" ] && [ "${HELIX_NO_SPLASH:-0}" != "1" ]; then
        echo "Starting splash screen..."
        "$SPLASH" >/dev/null 2>&1 &
        EARLY_SPLASH_PID=$!
        echo "$EARLY_SPLASH_PID" > /var/run/helix-splash.pid
    elif [ "${HELIX_NO_SPLASH:-0}" = "1" ]; then
        echo "Splash screen disabled (HELIX_NO_SPLASH=1)"
    fi

    # Use launcher script if available (handles watchdog)
    # Pass early splash PID so watchdog doesn't start another splash
    if [ -x "$LAUNCHER" ]; then
        SPLASH_ENV=""
        if [ -n "$EARLY_SPLASH_PID" ]; then
            SPLASH_ENV="HELIX_SPLASH_PID=$EARLY_SPLASH_PID"
        fi
        if command -v start-stop-daemon >/dev/null 2>&1; then
            start-stop-daemon -S -b -m -p "$PIDFILE" -x /bin/sh -- -c "cd $DAEMON_DIR && $SPLASH_ENV exec $LAUNCHER"
        else
            # Use sh -c for consistent environment variable handling
            /bin/sh -c "cd $DAEMON_DIR && $SPLASH_ENV exec $LAUNCHER" >> "$LOGFILE" 2>&1 &
            echo $! > "$PIDFILE"
        fi
    else
        # Fallback: start splash and daemon directly
        SPLASH_ARGS=$(start_splash)
        # BusyBox start-stop-daemon doesn't preserve working directory,
        # so we use sh -c with cd to ensure the daemon runs from the correct directory
        # (required for ui_xml/ and assets/ paths to resolve correctly)
        if command -v start-stop-daemon >/dev/null 2>&1; then
            start-stop-daemon -S -b -m -p "$PIDFILE" -x /bin/sh -- -c "cd $DAEMON_DIR && exec $DAEMON $SPLASH_ARGS"
        else
            (cd "$DAEMON_DIR" && "$DAEMON" $SPLASH_ARGS >> "$LOGFILE" 2>&1) &
            echo $! > "$PIDFILE"
        fi
    fi

    # Wait briefly and check if started
    sleep 2
    if [ -f "$PIDFILE" ]; then
        PID=$(cat "$PIDFILE")
        if kill -0 "$PID" 2>/dev/null; then
            echo "$NAME started (PID $PID)"
            return 0
        fi
    fi

    echo "Failed to start $NAME"
    stop_splash
    return 1
}

stop() {
    echo "Stopping $DESC..."

    # Remove flag file
    rm -f /tmp/helixscreen_active

    # Stop splash first
    stop_splash

    if [ -f "$PIDFILE" ]; then
        PID=$(cat "$PIDFILE")
        if kill -0 "$PID" 2>/dev/null; then
            kill "$PID"
            # Wait for process to exit
            for i in 1 2 3 4 5; do
                if ! kill -0 "$PID" 2>/dev/null; then
                    break
                fi
                sleep 1
            done
            # Force kill if still running
            if kill -0 "$PID" 2>/dev/null; then
                kill -9 "$PID" 2>/dev/null || true
            fi
        fi
        rm -f "$PIDFILE"
    fi

    # Also kill by name in case PID file is stale
    # Kill watchdog first to prevent crash dialog flash during clean shutdown
    if command -v killall >/dev/null 2>&1; then
        killall helix-watchdog 2>/dev/null || true
        killall helix-screen 2>/dev/null || true
        killall helix-splash 2>/dev/null || true
    else
        for pid in $(pidof helix-watchdog 2>/dev/null); do
            kill "$pid" 2>/dev/null || true
        done
        for pid in $(pidof helix-screen 2>/dev/null); do
            kill "$pid" 2>/dev/null || true
        done
        for pid in $(pidof helix-splash 2>/dev/null); do
            kill "$pid" 2>/dev/null || true
        done
    fi

    echo "$NAME stopped"
}

restart() {
    stop
    sleep 1
    start
}

status() {
    if [ -f "$PIDFILE" ]; then
        PID=$(cat "$PIDFILE")
        if kill -0 "$PID" 2>/dev/null; then
            echo "$NAME is running (PID $PID)"
            return 0
        fi
        echo "$NAME is not running (stale PID file)"
        return 1
    fi

    # Check if running without PID file
    if command -v pidof >/dev/null 2>&1; then
        PID=$(pidof helix-screen 2>/dev/null)
        if [ -n "$PID" ]; then
            echo "$NAME is running (PID $PID) [no PID file]"
            return 0
        fi
    fi

    echo "$NAME is not running"
    return 1
}

case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    restart|reload)
        restart
        ;;
    status)
        status
        ;;
    *)
        echo "Usage: $0 {start|stop|restart|status}"
        exit 1
        ;;
esac

exit $?
