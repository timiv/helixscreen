#!/bin/sh
# Copyright (C) 2025-2026 356C LLC
# SPDX-License-Identifier: GPL-3.0-or-later
#
# HelixScreen Uninstaller
# This file is auto-generated by bundle-uninstaller.sh
#
# Usage:
#   ./uninstall.sh              # Interactive uninstall
#   ./uninstall.sh --force      # Skip confirmation prompt
#
# This script:
#   1. Stops HelixScreen
#   2. Removes init script or systemd service
#   3. Removes installation directory and caches
#   4. Re-enables previous UI (GuppyScreen, KlipperScreen, etc.)
#   5. Removes Moonraker update_manager section

# Fail fast on any error
set -e

# Configuration
GITHUB_REPO="prestonbrown/helixscreen"
SERVICE_NAME="helixscreen"

# Previous UIs we may need to re-enable (for scanning)
PREVIOUS_UIS="guppyscreen GuppyScreen featherscreen FeatherScreen klipperscreen KlipperScreen"


# ============================================
# Module: common.sh
# ============================================

#
# Default configuration (can be overridden before sourcing)
: "${GITHUB_REPO:=prestonbrown/helixscreen}"
: "${INSTALL_DIR:=/opt/helixscreen}"
: "${SERVICE_NAME:=helixscreen}"

# Well-known paths (used by uninstall, clean, stop_service)
# AD5M: /opt/helixscreen or /root/printer_software/helixscreen
# K1: /usr/data/helixscreen
# Pi: /opt/helixscreen
HELIX_INSTALL_DIRS="/root/printer_software/helixscreen /opt/helixscreen /usr/data/helixscreen"

# Init script locations vary by platform/firmware
# AD5M Klipper Mod: S80, AD5M Forge-X: S90, K1: S99
HELIX_INIT_SCRIPTS="/etc/init.d/S80helixscreen /etc/init.d/S90helixscreen /etc/init.d/S99helixscreen"

# HelixScreen process names (order matters: watchdog first to prevent crash dialog)
HELIX_PROCESSES="helix-watchdog helix-screen helix-splash"

# Get sudo prefix needed for a file operation.
# Returns empty string if current user has write access, $SUDO otherwise.
# For existing files, checks file writability. For new files, checks parent dir.
# This avoids creating root-owned files in user-writable directories.
file_sudo() {
    local path="$1"
    if [ -e "$path" ]; then
        [ -w "$path" ] && echo "" || echo "$SUDO"
    else
        local dir
        dir="$(dirname "$path")"
        [ -w "$dir" ] && echo "" || echo "$SUDO"
    fi
}

# Track what we've done for cleanup
CLEANUP_TMP=false
CLEANUP_SERVICE=false
BACKUP_CONFIG=""
ORIGINAL_INSTALL_EXISTS=false

# Colors (if terminal supports it)
setup_colors() {
    if [ -t 1 ]; then
        RED='\033[0;31m'
        GREEN='\033[0;32m'
        YELLOW='\033[1;33m'
        CYAN='\033[0;36m'
        BOLD='\033[1m'
        NC='\033[0m'
    else
        RED=''
        GREEN=''
        YELLOW=''
        CYAN=''
        BOLD=''
        NC=''
    fi
}

# Initialize colors immediately
setup_colors

# Logging functions (printf %b interprets \033 escapes; BusyBox echo does not)
log_info() { printf '%b\n' "${CYAN}[INFO]${NC} $1" >&2; }
log_success() { printf '%b\n' "${GREEN}[OK]${NC} $1" >&2; }
log_warn() { printf '%b\n' "${YELLOW}[WARN]${NC} $1" >&2; }
log_error() { printf '%b\n' "${RED}[ERROR]${NC} $1" >&2; }

# Error handler - cleanup and report what went wrong
# Usage: trap 'error_handler $LINENO' ERR
error_handler() {
    local exit_code=$?
    local line_no=$1

    echo ""
    log_error "=========================================="
    log_error "Installation FAILED at line $line_no"
    log_error "Exit code: $exit_code"
    log_error "=========================================="
    echo ""

    # Cleanup temporary files
    if [ "$CLEANUP_TMP" = true ] && [ -d "$TMP_DIR" ]; then
        log_info "Cleaning up temporary files..."
        rm -rf "$TMP_DIR"
    fi

    # If we backed up config and install failed, try to restore state
    if [ -n "$BACKUP_CONFIG" ] && [ -f "$BACKUP_CONFIG" ]; then
        log_info "Restoring backed up configuration..."
        if $SUDO mkdir -p "${INSTALL_DIR}/config" 2>/dev/null; then
            if $SUDO cp "$BACKUP_CONFIG" "${INSTALL_DIR}/config/helixconfig.json" 2>/dev/null; then
                log_success "Configuration restored"
            else
                log_warn "Could not restore config. Backup saved at: $BACKUP_CONFIG"
            fi
        else
            log_warn "Could not create config directory. Backup saved at: $BACKUP_CONFIG"
        fi
    fi

    echo ""
    log_error "Installation was NOT completed."
    log_error "Your system should be in its original state."
    echo ""
    log_info "For help, please:"
    log_info "  1. Check the error message above"
    log_info "  2. Verify network connectivity"
    log_info "  3. Report issues at: https://github.com/${GITHUB_REPO}/issues"
    echo ""

    exit $exit_code
}

# Cleanup function for normal exit
cleanup_on_success() {
    if [ -d "$TMP_DIR" ]; then
        rm -rf "$TMP_DIR"
    fi
}

# Kill process(es) by name, using killall or pidof fallback
# Works on both GNU systems and BusyBox (AD5M/K1)
# Args: process_name [process_name2 ...]
# Returns: 0 if any process was killed, 1 if none found
kill_process_by_name() {
    local killed_any=false

    for proc in "$@"; do
        if command -v killall >/dev/null 2>&1; then
            if killall -0 "$proc" 2>/dev/null; then
                $SUDO killall "$proc" 2>/dev/null || true
                killed_any=true
            fi
        elif command -v pidof >/dev/null 2>&1; then
            local pids
            pids=$(pidof "$proc" 2>/dev/null)
            if [ -n "$pids" ]; then
                for pid in $pids; do
                    $SUDO kill "$pid" 2>/dev/null || true
                done
                killed_any=true
            fi
        fi
    done

    [ "$killed_any" = true ]
}

# Print post-install commands for the user
# Reads: INIT_SYSTEM, SERVICE_NAME, INIT_SCRIPT_DEST
print_post_install_commands() {
    echo "Useful commands:"
    if [ "$INIT_SYSTEM" = "systemd" ]; then
        echo "  systemctl status ${SERVICE_NAME}    # Check status"
        echo "  journalctl -u ${SERVICE_NAME} -f    # View logs"
        echo "  systemctl restart ${SERVICE_NAME}   # Restart"
    else
        echo "  ${INIT_SCRIPT_DEST} status   # Check status"
        echo "  cat /tmp/helixscreen.log            # View logs"
        echo "  ${INIT_SCRIPT_DEST} restart  # Restart"
    fi
}

# ============================================
# Module: platform.sh
# ============================================

#
# Default paths (may be overridden by set_install_paths)
: "${INSTALL_DIR:=/opt/helixscreen}"
: "${TMP_DIR:=}"

# Capture user-provided INSTALL_DIR before we potentially override it.
# If the user explicitly set INSTALL_DIR (and it's not the default),
# we respect their choice over auto-detection.
_USER_INSTALL_DIR="${INSTALL_DIR}"
[ "$_USER_INSTALL_DIR" = "/opt/helixscreen" ] && _USER_INSTALL_DIR=""
INIT_SCRIPT_DEST=""
PREVIOUS_UI_SCRIPT=""
AD5M_FIRMWARE=""
K1_FIRMWARE=""
KLIPPER_USER=""
KLIPPER_HOME=""

# Detect platform
# Returns: "ad5m", "k1", "pi", "pi32", or "unsupported"
detect_platform() {
    local arch kernel
    arch=$(uname -m)
    kernel=$(uname -r)

    # Check for AD5M (armv7l with specific kernel)
    if [ "$arch" = "armv7l" ]; then
        # AD5M has a specific kernel identifier
        if echo "$kernel" | grep -q "ad5m\|5.4.61"; then
            echo "ad5m"
            return
        fi
    fi

    # Check for Creality K1 series (Simple AF or stock with Klipper)
    # K1 uses buildroot and has /usr/data structure
    if [ -f /etc/os-release ] && grep -q "buildroot" /etc/os-release 2>/dev/null; then
        # Buildroot-based system - check for K1 indicators
        if [ -d "/usr/data" ]; then
            # Check for K1-specific indicators (require at least 2 for confidence)
            # - get_sn_mac.sh is a Creality-specific script
            # - /usr/data/pellcorp is Simple AF
            # - /usr/data/printer_data with klipper is a strong K1 indicator
            local k1_indicators=0
            [ -x "/usr/bin/get_sn_mac.sh" ] && k1_indicators=$((k1_indicators + 1))
            [ -d "/usr/data/pellcorp" ] && k1_indicators=$((k1_indicators + 1))
            [ -d "/usr/data/printer_data" ] && k1_indicators=$((k1_indicators + 1))
            [ -d "/usr/data/klipper" ] && k1_indicators=$((k1_indicators + 1))
            # Also check for Creality-specific paths
            [ -f "/usr/data/creality/userdata/config/system_config.json" ] && k1_indicators=$((k1_indicators + 1))

            if [ "$k1_indicators" -ge 2 ]; then
                echo "k1"
                return
            fi
        fi
    fi

    # Check for Raspberry Pi (aarch64 or armv7l)
    # Returns "pi" for 64-bit, "pi32" for 32-bit
    if [ "$arch" = "aarch64" ] || [ "$arch" = "armv7l" ]; then
        local is_pi=false
        if [ -f /etc/os-release ] && grep -q "Raspbian\|Debian" /etc/os-release; then
            is_pi=true
        fi
        # Also check for MainsailOS / BTT Pi / MKS
        if [ -d /home/pi ] || [ -d /home/mks ] || [ -d /home/biqu ]; then
            is_pi=true
        fi
        if [ "$is_pi" = true ]; then
            # Detect actual userspace bitness, not just kernel arch.
            # Many Pi systems run 64-bit kernel with 32-bit userspace,
            # which makes uname -m report aarch64 even though only
            # 32-bit binaries can execute.
            local userspace_bits
            userspace_bits=$(getconf LONG_BIT 2>/dev/null || echo "")
            if [ "$userspace_bits" = "64" ]; then
                echo "pi"
            elif [ "$userspace_bits" = "32" ]; then
                if [ "$arch" = "aarch64" ]; then
                    log_warn "64-bit kernel with 32-bit userspace detected — using pi32 build"
                fi
                echo "pi32"
            else
                # getconf unavailable — fall back to checking system binary
                if file /usr/bin/id 2>/dev/null | grep -q "64-bit"; then
                    echo "pi"
                elif file /usr/bin/id 2>/dev/null | grep -q "32-bit"; then
                    if [ "$arch" = "aarch64" ]; then
                        log_warn "64-bit kernel with 32-bit userspace detected — using pi32 build"
                    fi
                    echo "pi32"
                else
                    # Last resort: trust kernel arch
                    if [ "$arch" = "aarch64" ]; then
                        echo "pi"
                    else
                        echo "pi32"
                    fi
                fi
            fi
            return
        fi
    fi

    # Unknown ARM device - don't assume it's a Pi
    # Require explicit platform indicators to avoid false positives
    if [ "$arch" = "aarch64" ] || [ "$arch" = "armv7l" ]; then
        log_warn "Unknown ARM platform. Cannot auto-detect."
        echo "unsupported"
        return
    fi

    echo "unsupported"
}

# Detect the Klipper ecosystem user (who runs klipper/moonraker services)
# Detection cascade (most reliable first):
#   1. systemd: systemctl show klipper.service
#   2. Process table: ps for running klipper
#   3. printer_data scan: /home/*/printer_data
#   4. Well-known users: biqu, pi, mks
#   5. Fallback: root
# Sets: KLIPPER_USER, KLIPPER_HOME
detect_klipper_user() {
    # 1. systemd service owner (most reliable on Pi)
    if command -v systemctl >/dev/null 2>&1; then
        local svc_user
        svc_user=$(systemctl show -p User --value klipper.service 2>/dev/null) || true
        if [ -n "$svc_user" ] && [ "$svc_user" != "root" ] && id "$svc_user" >/dev/null 2>&1; then
            KLIPPER_USER="$svc_user"
            KLIPPER_HOME=$(eval echo "~$svc_user")
            log_info "Klipper user (systemd): $KLIPPER_USER"
            return 0
        fi
    fi

    # 2. Process table (catches running instances)
    local ps_user
    ps_user=$(ps -eo user,comm 2>/dev/null | awk '/klipper$/ && !/grep/ {print $1; exit}') || true
    if [ -n "$ps_user" ] && [ "$ps_user" != "root" ] && id "$ps_user" >/dev/null 2>&1; then
        KLIPPER_USER="$ps_user"
        KLIPPER_HOME=$(eval echo "~$ps_user")
        log_info "Klipper user (process): $KLIPPER_USER"
        return 0
    fi

    # 3. printer_data directory scan
    local pd_dir
    for pd_dir in /home/*/printer_data; do
        [ -d "$pd_dir" ] || continue
        local pd_user
        pd_user=$(echo "$pd_dir" | sed 's|^/home/||;s|/printer_data$||')
        if [ -n "$pd_user" ] && id "$pd_user" >/dev/null 2>&1; then
            KLIPPER_USER="$pd_user"
            KLIPPER_HOME="/home/$pd_user"
            log_info "Klipper user (printer_data): $KLIPPER_USER"
            return 0
        fi
    done

    # 4. Well-known users (checked in priority order)
    local known_user
    for known_user in biqu pi mks; do
        if id "$known_user" >/dev/null 2>&1; then
            KLIPPER_USER="$known_user"
            KLIPPER_HOME="/home/$known_user"
            log_info "Klipper user (well-known): $KLIPPER_USER"
            return 0
        fi
    done

    # 5. Fallback: root (embedded platforms, AD5M, K1)
    KLIPPER_USER="root"
    KLIPPER_HOME="/root"
    log_info "Klipper user (fallback): root"
    return 0
}

# Detect AD5M firmware variant (Klipper Mod vs Forge-X)
# Only called when platform is "ad5m"
# Returns: "klipper_mod" or "forge_x"
detect_ad5m_firmware() {
    # Klipper Mod indicators - check for its specific directory structure
    # Klipper Mod runs in a chroot on /mnt/data/.klipper_mod/chroot
    # and puts printer software in /root/printer_software/
    if [ -d "/root/printer_software" ] || [ -d "/mnt/data/.klipper_mod" ]; then
        echo "klipper_mod"
        return
    fi

    # Forge-X indicators - check for its mod overlay structure
    if [ -d "/opt/config/mod/.root" ]; then
        echo "forge_x"
        return
    fi

    # Default to forge_x (original behavior, most common)
    echo "forge_x"
}

# Detect K1 firmware variant (Simple AF vs other)
# Only called when platform is "k1"
# Returns: "simple_af" or "stock_klipper"
detect_k1_firmware() {
    # Simple AF (pellcorp/creality) indicators
    if [ -d "/usr/data/pellcorp" ]; then
        echo "simple_af"
        return
    fi

    # Check for GuppyScreen which Simple AF installs
    if [ -d "/usr/data/guppyscreen" ] && [ -f "/etc/init.d/S99guppyscreen" ]; then
        echo "simple_af"
        return
    fi

    # Default to stock_klipper (generic K1 with Klipper)
    echo "stock_klipper"
}

# Detect Pi install directory based on Klipper ecosystem presence
# Cascade (first match wins):
#   1. User explicitly set INSTALL_DIR → keep it
#   2. ~/klipper or ~/moonraker exists → ~/helixscreen
#   3. ~/printer_data exists → ~/helixscreen
#   4. moonraker.service is active → ~/helixscreen
#   5. Fallback → /opt/helixscreen
# Requires: KLIPPER_HOME to be set (by detect_klipper_user)
# Sets: INSTALL_DIR
detect_pi_install_dir() {
    # 1. User explicitly set INSTALL_DIR — respect their choice
    if [ -n "$_USER_INSTALL_DIR" ]; then
        INSTALL_DIR="$_USER_INSTALL_DIR"
        log_info "Install directory (user override): $INSTALL_DIR"
        return 0
    fi

    # Need KLIPPER_HOME for ecosystem detection
    if [ -z "$KLIPPER_HOME" ]; then
        INSTALL_DIR="/opt/helixscreen"
        return 0
    fi

    # 2. Klipper or Moonraker source directories
    if [ -d "$KLIPPER_HOME/klipper" ] || [ -d "$KLIPPER_HOME/moonraker" ]; then
        INSTALL_DIR="$KLIPPER_HOME/helixscreen"
        log_info "Install directory (klipper ecosystem): $INSTALL_DIR"
        return 0
    fi

    # 3. printer_data directory (Klipper config structure)
    if [ -d "$KLIPPER_HOME/printer_data" ]; then
        INSTALL_DIR="$KLIPPER_HOME/helixscreen"
        log_info "Install directory (printer_data): $INSTALL_DIR"
        return 0
    fi

    # 4. Moonraker service running (ecosystem present but maybe different layout)
    if command -v systemctl >/dev/null 2>&1; then
        if systemctl is-active --quiet moonraker.service 2>/dev/null || \
           systemctl is-active --quiet moonraker 2>/dev/null; then
            INSTALL_DIR="$KLIPPER_HOME/helixscreen"
            log_info "Install directory (moonraker service): $INSTALL_DIR"
            return 0
        fi
    fi

    # 5. Fallback: no ecosystem detected
    INSTALL_DIR="/opt/helixscreen"
    return 0
}

# Detect best temp directory for extraction
# Mirrors get_helix_cache_dir() heuristic from app_globals.cpp:
# tries candidates in order, picks first writable dir with >= 100MB free.
# User can override via TMP_DIR env var.
# Sets: TMP_DIR
detect_tmp_dir() {
    # User already set TMP_DIR — respect it
    if [ -n "${TMP_DIR:-}" ]; then
        log_info "Temp directory (user override): $TMP_DIR"
        return 0
    fi

    local required_mb=100
    local candidates="/data/helixscreen-install /mnt/data/helixscreen-install /usr/data/helixscreen-install /var/tmp/helixscreen-install /tmp/helixscreen-install"

    for candidate in $candidates; do
        local check_dir
        check_dir=$(dirname "$candidate")

        # Must exist (or be creatable) and be writable
        if [ ! -d "$check_dir" ]; then
            continue
        fi
        if [ ! -w "$check_dir" ] && ! $SUDO test -w "$check_dir" 2>/dev/null; then
            continue
        fi

        # Check free space (BusyBox df: KB in $4)
        local available_mb
        available_mb=$(df "$check_dir" 2>/dev/null | tail -1 | awk '{print int($4/1024)}')
        if [ -z "$available_mb" ] || [ "$available_mb" -lt "$required_mb" ]; then
            continue
        fi

        TMP_DIR="$candidate"
        if [ "$check_dir" != "/tmp" ]; then
            log_info "Temp directory: $TMP_DIR (${available_mb}MB free)"
        fi
        return 0
    done

    # Last resort — /tmp even if small (will fail later at extraction with a clear error)
    TMP_DIR="/tmp/helixscreen-install"
    log_warn "No temp directory with ${required_mb}MB+ free found, using /tmp"
}

# Set installation paths based on platform and firmware
# Sets: INSTALL_DIR, INIT_SCRIPT_DEST, PREVIOUS_UI_SCRIPT, TMP_DIR
set_install_paths() {
    local platform=$1
    local firmware=${2:-}

    if [ "$platform" = "ad5m" ]; then
        case "$firmware" in
            klipper_mod)
                INSTALL_DIR="/root/printer_software/helixscreen"
                INIT_SCRIPT_DEST="/etc/init.d/S80helixscreen"
                PREVIOUS_UI_SCRIPT="/etc/init.d/S80klipperscreen"
                log_info "AD5M firmware: Klipper Mod"
                log_info "Install directory: ${INSTALL_DIR}"
                ;;
            forge_x|*)
                INSTALL_DIR="/opt/helixscreen"
                INIT_SCRIPT_DEST="/etc/init.d/S90helixscreen"
                PREVIOUS_UI_SCRIPT="/opt/config/mod/.root/S80guppyscreen"
                log_info "AD5M firmware: Forge-X"
                log_info "Install directory: ${INSTALL_DIR}"
                ;;
        esac
    elif [ "$platform" = "k1" ]; then
        # Creality K1 series - uses /usr/data structure
        case "$firmware" in
            simple_af|*)
                INSTALL_DIR="/usr/data/helixscreen"
                INIT_SCRIPT_DEST="/etc/init.d/S99helixscreen"
                PREVIOUS_UI_SCRIPT="/etc/init.d/S99guppyscreen"
                log_info "K1 firmware: Simple AF"
                log_info "Install directory: ${INSTALL_DIR}"
                ;;
        esac
    else
        # Pi and other platforms — detect klipper user, then auto-detect install dir
        INIT_SCRIPT_DEST="/etc/init.d/S90helixscreen"
        PREVIOUS_UI_SCRIPT=""
        detect_klipper_user
        detect_pi_install_dir
    fi

    # Auto-detect best temp directory (all platforms)
    detect_tmp_dir
}

# Create symlink from printer_data/config/helixscreen → INSTALL_DIR/config
# Allows Mainsail/Fluidd users to edit HelixScreen config from the web UI.
# Only applies to Pi/Klipper platforms where printer_data exists.
# Gracefully skips if printer_data/config doesn't exist or permissions fail.
# Reads: KLIPPER_HOME, INSTALL_DIR
setup_config_symlink() {
    # Only proceed if we have a Klipper home and install directory
    if [ -z "${KLIPPER_HOME:-}" ] || [ -z "${INSTALL_DIR:-}" ]; then
        return 0
    fi

    local config_dir="${KLIPPER_HOME}/printer_data/config"
    local symlink_path="${config_dir}/helixscreen"
    local target="${INSTALL_DIR}/config"

    # Skip if printer_data/config doesn't exist
    if [ ! -d "$config_dir" ]; then
        log_info "No printer_data/config found, skipping config symlink"
        return 0
    fi

    # Skip if target config directory doesn't exist
    if [ ! -d "$target" ]; then
        log_warn "Install config directory not found: $target"
        return 0
    fi

    # Check if symlink already exists
    if [ -L "$symlink_path" ]; then
        local current_target
        current_target=$(readlink "$symlink_path" 2>/dev/null || echo "")
        if [ "$current_target" = "$target" ]; then
            log_info "Config symlink already exists and is correct"
            return 0
        fi
        # Wrong target — update it
        log_info "Updating config symlink (was: $current_target)"
        $(file_sudo "$symlink_path") rm -f "$symlink_path"
    elif [ -e "$symlink_path" ]; then
        # Something exists but isn't a symlink — don't destroy it
        log_warn "Config symlink path already exists as a regular file/directory: $symlink_path"
        log_warn "Skipping symlink creation to avoid data loss"
        return 0
    fi

    # Create the symlink
    if $(file_sudo "$config_dir") ln -s "$target" "$symlink_path" 2>/dev/null; then
        log_success "Config symlink: $symlink_path → $target"
        log_info "You can now edit HelixScreen config from Mainsail/Fluidd"
    else
        log_warn "Could not create config symlink (permission denied?)"
        log_warn "To create manually: ln -s $target $symlink_path"
    fi

    return 0
}

# ============================================
# Module: permissions.sh
# ============================================

#
# Initialize SUDO (will be set by check_permissions)
SUDO=""
# Check if running as root (required for AD5M/K1, optional for Pi)
# Sets: SUDO variable ("sudo" or "")
check_permissions() {
    local platform=$1

    if [ "$platform" = "ad5m" ] || [ "$platform" = "k1" ]; then
        if [ "$(id -u)" != "0" ]; then
            log_error "Installation on $platform requires root privileges."
            log_error "Please run: sudo $0 $*"
            exit 1
        fi
        SUDO=""
    else
        # Pi: warn if not root but allow sudo
        if [ "$(id -u)" != "0" ]; then
            if ! command -v sudo >/dev/null 2>&1; then
                log_error "Not running as root and sudo is not available."
                log_error "Please run as root or install sudo."
                exit 1
            fi
            log_info "Not running as root. Will use sudo for privileged operations."
            SUDO="sudo"
        else
            SUDO=""
        fi
    fi
}

# ============================================
# Module: requirements.sh
# ============================================

#
# Initialize INIT_SYSTEM (will be set by detect_init_system)
INIT_SYSTEM=""
# Check required commands exist
# Requires: curl or wget, tar, gunzip
check_requirements() {
    local missing=""

    # Need either curl or wget
    if ! command -v curl >/dev/null 2>&1 && ! command -v wget >/dev/null 2>&1; then
        missing="curl or wget"
    fi

    # Need tar
    if ! command -v tar >/dev/null 2>&1; then
        if [ -n "$missing" ]; then
            missing="$missing, tar"
        else
            missing="tar"
        fi
    fi

    # Need gunzip (for AD5M BusyBox tar which doesn't support -z)
    if ! command -v gunzip >/dev/null 2>&1; then
        if [ -n "$missing" ]; then
            missing="$missing, gunzip"
        else
            missing="gunzip"
        fi
    fi

    if [ -n "$missing" ]; then
        log_error "Missing required commands: $missing"
        log_error "Please install them and try again."
        exit 1
    fi

    log_success "All required commands available"
}

# Install runtime dependencies for Pi platform
# Required for DRM display and evdev input handling
# AD5M uses framebuffer with static linking, no deps needed
install_runtime_deps() {
    local platform=$1

    # Only needed for Pi (32-bit and 64-bit) - AD5M uses framebuffer with static linking
    if [ "$platform" != "pi" ] && [ "$platform" != "pi32" ]; then
        return 0
    fi

    log_info "Checking runtime dependencies for display/input..."

    # Required libraries for DRM display and libinput
    # Note: GPU libs (libgles2, libegl1, libgbm1) not needed - using software rendering
    local deps="libdrm2 libinput10"
    local missing=""

    for dep in $deps; do
        # Check if package is installed (dpkg-query returns 0 if installed)
        if ! dpkg-query -W -f='${Status}' "$dep" 2>/dev/null | grep -q "install ok installed"; then
            if [ -n "$missing" ]; then
                missing="$missing $dep"
            else
                missing="$dep"
            fi
        fi
    done

    if [ -n "$missing" ]; then
        log_info "Installing missing libraries: $missing"
        $SUDO apt-get update -qq
        # shellcheck disable=SC2086
        $SUDO apt-get install -y --no-install-recommends $missing
        log_success "Runtime libraries installed"
    else
        log_success "All runtime libraries already installed"
    fi
}

# Check available disk space
# Requires at least 50MB free on the install directory's filesystem
# Note: INSTALL_DIR must be set before calling this function
check_disk_space() {
    local platform=$1
    local required_mb=50

    # Get the parent directory of install location (the filesystem to check)
    local check_dir
    check_dir=$(dirname "${INSTALL_DIR:-/opt/helixscreen}")
    # Walk up until we find an existing directory
    while [ ! -d "$check_dir" ] && [ "$check_dir" != "/" ]; do
        check_dir=$(dirname "$check_dir")
    done
    if [ "$check_dir" = "/" ]; then
        check_dir="/"
    fi

    # Get available space in MB
    local available_mb
    if [ "$platform" = "ad5m" ] || [ "$platform" = "k1" ]; then
        # BusyBox df output format: blocks are in KB by default
        available_mb=$(df "$check_dir" 2>/dev/null | tail -1 | awk '{print int($4/1024)}')
    else
        # GNU df with -m flag outputs in MB
        available_mb=$(df -m "$check_dir" 2>/dev/null | tail -1 | awk '{print $4}')
    fi

    if [ -n "$available_mb" ] && [ "$available_mb" -lt "$required_mb" ]; then
        log_error "Insufficient disk space on $check_dir"
        log_error "Required: ${required_mb}MB, Available: ${available_mb}MB"
        exit 1
    fi

    log_info "Disk space check: ${available_mb}MB available on $check_dir"
}

# Detect init system (systemd vs SysV)
# Sets: INIT_SYSTEM to "systemd" or "sysv"
detect_init_system() {
    # Check for systemd
    if command -v systemctl >/dev/null 2>&1 && [ -d /run/systemd/system ]; then
        INIT_SYSTEM="systemd"
        log_info "Init system: systemd"
        return
    fi

    # Check for SysV init (BusyBox or traditional)
    if [ -d /etc/init.d ]; then
        INIT_SYSTEM="sysv"
        log_info "Init system: SysV (BusyBox/traditional)"
        return
    fi

    log_error "Could not detect init system."
    log_error "Neither systemd nor /etc/init.d found."
    exit 1
}

# Check that Klipper and Moonraker are running (AD5M + K1 only)
# These platforms require local Klipper/Moonraker; without them HelixScreen
# has nothing to connect to. Warns and prompts for confirmation.
check_klipper_ecosystem() {
    local platform=$1

    # Only relevant for embedded platforms with local Klipper
    case "$platform" in
        ad5m|k1) ;;
        *) return 0 ;;
    esac

    local warnings=""

    # Check Klipper process
    # Klipper runs as "klippy" (python module) or "klipper" (service name)
    if ! ps | grep -v grep | grep -q -e '[Kk]lipper' -e '[Kk]lippy'; then
        warnings="Klipper does not appear to be running."
    fi

    # Check Moonraker process
    if ! ps | grep -v grep | grep -q '[Mm]oonraker'; then
        if [ -n "$warnings" ]; then
            warnings="$warnings
Moonraker does not appear to be running."
        else
            warnings="Moonraker does not appear to be running."
        fi
    fi

    # If Moonraker process is up, verify it responds on the expected port
    if ps | grep -v grep | grep -q '[Mm]oonraker'; then
        if command -v wget >/dev/null 2>&1; then
            if ! wget -q -O /dev/null --timeout=5 "http://127.0.0.1:7125/server/info" 2>/dev/null; then
                if [ -n "$warnings" ]; then
                    warnings="$warnings
Moonraker is running but not responding on http://127.0.0.1:7125."
                else
                    warnings="Moonraker is running but not responding on http://127.0.0.1:7125."
                fi
            fi
        elif command -v curl >/dev/null 2>&1; then
            if ! curl -sf --connect-timeout 5 "http://127.0.0.1:7125/server/info" >/dev/null 2>&1; then
                if [ -n "$warnings" ]; then
                    warnings="$warnings
Moonraker is running but not responding on http://127.0.0.1:7125."
                else
                    warnings="Moonraker is running but not responding on http://127.0.0.1:7125."
                fi
            fi
        fi
    fi

    # Everything looks good
    if [ -z "$warnings" ]; then
        log_success "Klipper and Moonraker are running"
        return 0
    fi

    # Show warnings and prompt
    log_warn ""
    log_warn "WARNING: Klipper ecosystem check failed:"
    # Print each warning line separately
    echo "$warnings" | while IFS= read -r line; do
        log_warn "  - $line"
    done
    log_warn ""
    log_warn "HelixScreen requires Klipper and Moonraker to function."
    log_warn "It will install but won't work until these services are available."

    # Non-interactive mode: just warn and continue
    if [ ! -t 0 ]; then
        log_warn "Non-interactive mode: continuing anyway."
        return 0
    fi

    printf "Continue anyway? [y/N] "
    read -r answer
    case "$answer" in
        [Yy]|[Yy][Ee][Ss])
            log_info "Continuing installation..."
            return 0
            ;;
        *)
            log_error "Installation cancelled."
            exit 1
            ;;
    esac
}

# ============================================
# Module: forgex.sh
# ============================================

#
# Configure ForgeX display settings for HelixScreen
# We use GUPPY mode because ForgeX handles backlight properly in this mode.
# STOCK mode expects ffstartup-arm to manage display/backlight which doesn't work for us.
# We disable GuppyScreen's init scripts so HelixScreen takes over the display.
configure_forgex_display() {
    var_file="/opt/config/mod_data/variables.cfg"
    guppy_init="/opt/config/mod/.root/S80guppyscreen"
    tslib_init="/opt/config/mod/.root/S35tslib"
    changed=false

    # Set display mode to GUPPY (required for backlight to work)
    if [ -f "$var_file" ]; then
        if grep -q "display[[:space:]]*=[[:space:]]*'STOCK'" "$var_file"; then
            log_info "Setting ForgeX display mode to GUPPY..."
            $SUDO sed -i "s/display[[:space:]]*=[[:space:]]*'STOCK'/display = 'GUPPY'/" "$var_file"
            changed=true
        elif grep -q "display[[:space:]]*=[[:space:]]*'HEADLESS'" "$var_file"; then
            log_info "Setting ForgeX display mode to GUPPY..."
            $SUDO sed -i "s/display[[:space:]]*=[[:space:]]*'HEADLESS'/display = 'GUPPY'/" "$var_file"
            changed=true
        fi
    fi

    # Disable GuppyScreen init script (remove execute permission)
    if [ -x "$guppy_init" ]; then
        log_info "Disabling GuppyScreen init script..."
        $SUDO chmod -x "$guppy_init"
        changed=true
    fi

    # Disable tslib init script (GuppyScreen's touch input layer)
    # HelixScreen uses its own input handling
    if [ -x "$tslib_init" ]; then
        log_info "Disabling tslib init script..."
        $SUDO chmod -x "$tslib_init"
        changed=true
    fi

    if [ "$changed" = true ]; then
        log_success "ForgeX configured for HelixScreen (GUPPY mode, GuppyScreen disabled)"
        return 0
    fi
    return 1
}

# Patch ForgeX screen.sh to skip non-100 backlight control when HelixScreen is active
# ForgeX's headless.cfg runs a delayed_gcode that dims the backlight 3 seconds after
# Klipper starts. This patch blocks dimming calls but allows the S99root 0→100 cycle.
#
# The smart patch:
# - Allows "backlight 100" (needed for S99root initialization cycle)
# - Blocks other values (10, 0, etc.) when helixscreen_active flag exists
patch_forgex_screen_sh() {
    screen_sh="/opt/config/mod/.shell/screen.sh"

    if [ ! -f "$screen_sh" ]; then
        log_info "ForgeX screen.sh not found, skipping patch"
        return 1
    fi

    # Check if already patched (look for the smart patch signature)
    if grep -q 'helixscreen_active.*!=.*100' "$screen_sh" 2>/dev/null; then
        log_info "ForgeX screen.sh already has smart patch"
        return 0
    fi

    # Remove old-style patch if present (blocks ALL backlight when flag exists)
    if grep -q "helixscreen_active" "$screen_sh" 2>/dev/null; then
        log_info "Removing old-style patch from screen.sh..."
        tmp_file="${screen_sh}.tmp"
        grep -v "helixscreen_active\|# Skip if HelixScreen" "$screen_sh" > "$tmp_file"
        $SUDO mv "$tmp_file" "$screen_sh"
        $SUDO chmod +x "$screen_sh"
    fi

    # Find the backlight) case and add our guard
    if ! grep -q "^[[:space:]]*backlight)" "$screen_sh"; then
        log_info "Could not find backlight case in screen.sh"
        return 1
    fi

    log_info "Patching ForgeX screen.sh with smart backlight control..."

    # Use awk to insert our check after "backlight)" line (BusyBox compatible)
    # Smart patch: only block non-100 values, allowing S99root's 0→100 init cycle
    tmp_file="${screen_sh}.tmp"
    awk '
    /^[[:space:]]*backlight\)/ {
        print
        print "        # Skip non-100 backlight changes when HelixScreen is controlling display"
        print "        # Allows S99root 0->100 init cycle but blocks Klipper eco dimming"
        print "        if [ -f /tmp/helixscreen_active ] && [ \"$2\" != \"100\" ]; then"
        print "            exit 0"
        print "        fi"
        next
    }
    { print }
    ' "$screen_sh" > "$tmp_file"

    if [ -s "$tmp_file" ] && grep -q 'helixscreen_active.*!=.*100' "$tmp_file" 2>/dev/null; then
        $SUDO mv "$tmp_file" "$screen_sh"
        $SUDO chmod +x "$screen_sh"
        log_success "ForgeX screen.sh patched with smart backlight control"
        return 0
    else
        rm -f "$tmp_file"
        log_warn "Failed to patch ForgeX screen.sh"
        return 1
    fi
}

# Remove HelixScreen patch from ForgeX screen.sh (for uninstall)
unpatch_forgex_screen_sh() {
    screen_sh="/opt/config/mod/.shell/screen.sh"

    if [ ! -f "$screen_sh" ]; then
        return 1
    fi

    # Check if patched
    if ! grep -q "helixscreen_active" "$screen_sh" 2>/dev/null; then
        log_info "ForgeX screen.sh not patched, nothing to remove"
        return 0
    fi

    log_info "Removing HelixScreen patch from ForgeX screen.sh..."

    # Use awk to remove only our specific block (BusyBox compatible)
    # Match and skip: comment line, if line with helixscreen_active, exit 0, fi
    tmp_file="${screen_sh}.tmp"
    awk '
    /# Skip if HelixScreen is controlling the display/ { skip=1; next }
    /if \[ -f \/tmp\/helixscreen_active \]; then/ { skip=1; next }
    skip && /^[[:space:]]*exit 0[[:space:]]*$/ { next }
    skip && /^[[:space:]]*fi[[:space:]]*$/ { skip=0; next }
    { print }
    ' "$screen_sh" > "$tmp_file"

    if [ -s "$tmp_file" ]; then
        $SUDO mv "$tmp_file" "$screen_sh"
        $SUDO chmod +x "$screen_sh"
    else
        rm -f "$tmp_file"
        log_warn "Failed to unpatch ForgeX screen.sh"
        return 1
    fi

    # Verify removal
    if grep -q "helixscreen_active" "$screen_sh" 2>/dev/null; then
        log_warn "Could not fully remove patch from screen.sh"
        return 1
    fi

    log_success "ForgeX screen.sh patch removed"
    return 0
}

# Disable stock FlashForge UI in auto_run.sh
# The stock firmware UI (ffstartup-arm/firmwareExe) is started by /opt/auto_run.sh
# which runs AFTER init scripts. We comment out the line to prevent it starting.
disable_stock_firmware_ui() {
    auto_run="/opt/auto_run.sh"
    if [ -f "$auto_run" ]; then
        # Check if ffstartup-arm line exists and is not already commented
        if grep -q "^/opt/PROGRAM/ffstartup-arm" "$auto_run"; then
            log_info "Disabling stock FlashForge UI in auto_run.sh..."
            # Comment out the ffstartup-arm line
            $SUDO sed -i 's|^/opt/PROGRAM/ffstartup-arm|# Disabled by HelixScreen: /opt/PROGRAM/ffstartup-arm|' "$auto_run"
            log_success "Stock FlashForge UI disabled"
            return 0
        fi
    fi
    return 1
}

# Re-enable stock FlashForge UI in auto_run.sh (for uninstall)
restore_stock_firmware_ui() {
    auto_run="/opt/auto_run.sh"
    if [ -f "$auto_run" ]; then
        # Check if our disabled line exists
        if grep -q "^# Disabled by HelixScreen: /opt/PROGRAM/ffstartup-arm" "$auto_run"; then
            log_info "Re-enabling stock FlashForge UI in auto_run.sh..."
            # Uncomment the ffstartup-arm line
            $SUDO sed -i 's|^# Disabled by HelixScreen: /opt/PROGRAM/ffstartup-arm|/opt/PROGRAM/ffstartup-arm|' "$auto_run"
            log_success "Stock FlashForge UI re-enabled"
            return 0
        fi
    fi
    return 1
}

# Patch ForgeX screen.sh to skip screen drawing when HelixScreen is active
# ForgeX's S99root calls draw_splash, draw_loading, and boot_message which write
# directly to the framebuffer, overwriting our splash screen during boot.
patch_forgex_screen_drawing() {
    screen_sh="/opt/config/mod/.shell/screen.sh"

    if [ ! -f "$screen_sh" ]; then
        log_info "ForgeX screen.sh not found, skipping screen drawing patch"
        return 1
    fi

    # Check if already patched (look for our signature in draw_splash)
    if grep -q 'draw_splash)' "$screen_sh" && \
       grep -A2 'draw_splash)' "$screen_sh" | grep -q 'helixscreen_active'; then
        log_info "ForgeX screen.sh already has screen drawing patches"
        return 0
    fi

    log_info "Patching ForgeX screen.sh to skip drawing when HelixScreen active..."

    # Patch draw_loading, draw_splash, and boot_message cases
    # Add helixscreen_active check after each case label
    tmp_file="${screen_sh}.tmp"
    awk '
    /^[[:space:]]*(draw_loading|draw_splash|boot_message)\)/ {
        print
        print "        # Skip when HelixScreen is controlling display"
        print "        if [ -f /tmp/helixscreen_active ]; then"
        print "            exit 0"
        print "        fi"
        next
    }
    { print }
    ' "$screen_sh" > "$tmp_file"

    if [ -s "$tmp_file" ] && grep -q 'helixscreen_active' "$tmp_file" 2>/dev/null; then
        $SUDO mv "$tmp_file" "$screen_sh"
        $SUDO chmod +x "$screen_sh"
        log_success "ForgeX screen.sh patched for screen drawing"
        return 0
    else
        rm -f "$tmp_file"
        log_warn "Failed to patch ForgeX screen.sh for screen drawing"
        return 1
    fi
}

# Remove screen drawing patches from ForgeX screen.sh (for uninstall)
unpatch_forgex_screen_drawing() {
    screen_sh="/opt/config/mod/.shell/screen.sh"

    if [ ! -f "$screen_sh" ]; then
        return 1
    fi

    # Check if our drawing patches are present
    if ! grep -q '# Skip when HelixScreen is controlling display' "$screen_sh" 2>/dev/null; then
        log_info "ForgeX screen.sh has no drawing patches, nothing to remove"
        return 0
    fi

    log_info "Removing HelixScreen drawing patches from ForgeX screen.sh..."

    # Remove our 4-line block: comment + if + exit 0 + fi
    tmp_file="${screen_sh}.tmp"
    awk '
    /# Skip when HelixScreen is controlling display/ { skip=1; next }
    skip && /if \[ -f \/tmp\/helixscreen_active \]; then/ { next }
    skip && /^[[:space:]]*exit 0[[:space:]]*$/ { next }
    skip && /^[[:space:]]*fi[[:space:]]*$/ { skip=0; next }
    { print }
    ' "$screen_sh" > "$tmp_file"

    if [ -s "$tmp_file" ]; then
        $SUDO mv "$tmp_file" "$screen_sh"
        $SUDO chmod +x "$screen_sh"
    else
        rm -f "$tmp_file"
        log_warn "Failed to unpatch ForgeX screen.sh drawing patches"
        return 1
    fi

    # Verify removal
    if grep -q '# Skip when HelixScreen is controlling display' "$screen_sh" 2>/dev/null; then
        log_warn "Could not fully remove drawing patches from screen.sh"
        return 1
    fi

    log_success "ForgeX screen.sh drawing patches removed"
    return 0
}

# Install logged wrapper to prevent direct framebuffer writes during boot
# ForgeX's 'logged' binary writes directly to /dev/fb0 when --send-to-screen is used,
# bypassing our screen.sh patches. This wrapper strips that flag when HelixScreen is active.
install_forgex_logged_wrapper() {
    logged_bin="/opt/config/mod/.bin/exec/logged"
    logged_real="/opt/config/mod/.bin/exec/logged-real"
    logged_wrapper="/opt/config/mod/.bin/exec/logged-wrapper"

    if [ ! -f "$logged_bin" ]; then
        log_info "ForgeX logged binary not found, skipping wrapper"
        return 1
    fi

    # Always re-write the wrapper to pick up fixes on upgrade
    if [ -L "$logged_bin" ] && [ -f "$logged_real" ]; then
        log_info "Updating ForgeX logged wrapper..."
    elif [ -L "$logged_bin" ]; then
        # Don't wrap if it's already a symlink to something else
        log_warn "ForgeX logged is already a symlink, skipping wrapper"
        return 1
    else
        log_info "Installing ForgeX logged wrapper..."
    fi

    # Create the wrapper script
    cat > "$logged_wrapper" << 'WRAPPER_EOF'
# Wrapper for logged that strips --send-to-screen when HelixScreen is active
# The logged binary writes directly to /dev/fb0, bypassing screen.sh patches

if [ -f /tmp/helixscreen_active ]; then
    # Remove --send-to-screen and related args, keep everything else
    args=""
    skip_next=0
    for arg in "$@"; do
        if [ $skip_next -eq 1 ]; then
            skip_next=0
            continue
        fi
        case "$arg" in
            --send-to-screen) continue ;;
            --screen-no-followup) continue ;;
            --screen-level) skip_next=1; continue ;;
            --screen-queue) skip_next=1; continue ;;
            *) args="$args $arg" ;;
        esac
    done
    exec /opt/config/mod/.bin/exec/logged-real $args
else
    exec /opt/config/mod/.bin/exec/logged-real "$@"
fi
WRAPPER_EOF

    $SUDO chmod +x "$logged_wrapper"

    # Move original to logged-real and symlink logged to wrapper (skip if already done)
    if [ ! -L "$logged_bin" ]; then
        $SUDO mv "$logged_bin" "$logged_real"
        $SUDO ln -s "$logged_wrapper" "$logged_bin"
    fi

    if [ -L "$logged_bin" ] && [ -f "$logged_real" ]; then
        log_success "ForgeX logged wrapper installed"
        return 0
    else
        # Rollback on failure
        [ -f "$logged_real" ] && $SUDO mv "$logged_real" "$logged_bin"
        rm -f "$logged_wrapper"
        log_warn "Failed to install ForgeX logged wrapper"
        return 1
    fi
}

# Remove logged wrapper (for uninstall)
uninstall_forgex_logged_wrapper() {
    logged_bin="/opt/config/mod/.bin/exec/logged"
    logged_real="/opt/config/mod/.bin/exec/logged-real"
    logged_wrapper="/opt/config/mod/.bin/exec/logged-wrapper"

    if [ ! -f "$logged_real" ]; then
        return 0  # Not installed
    fi

    log_info "Removing ForgeX logged wrapper..."

    $SUDO rm -f "$logged_bin"
    $SUDO mv "$logged_real" "$logged_bin"
    $SUDO rm -f "$logged_wrapper"

    log_success "ForgeX logged wrapper removed"
    return 0
}

# Uninstall ForgeX-specific configuration (for uninstall)
# Restores display mode, stock UI, screen.sh, GuppyScreen/tslib init scripts,
# and cleans up backup files from manual patches.
# Note: Sets caller's `restored_ui` variable via dynamic scoping.
uninstall_forgex() {
    # Restore ForgeX display mode to GUPPY (from HEADLESS or STOCK)
    if [ -f "/opt/config/mod_data/variables.cfg" ]; then
        if grep -q "display[[:space:]]*=[[:space:]]*'HEADLESS'" "/opt/config/mod_data/variables.cfg"; then
            log_info "Restoring ForgeX display mode to GUPPY..."
            $SUDO sed -i "s/display[[:space:]]*=[[:space:]]*'HEADLESS'/display = 'GUPPY'/" "/opt/config/mod_data/variables.cfg"
        elif grep -q "display[[:space:]]*=[[:space:]]*'STOCK'" "/opt/config/mod_data/variables.cfg"; then
            log_info "Restoring ForgeX display mode to GUPPY..."
            $SUDO sed -i "s/display[[:space:]]*=[[:space:]]*'STOCK'/display = 'GUPPY'/" "/opt/config/mod_data/variables.cfg"
        fi
    fi

    # Restore stock FlashForge UI in auto_run.sh
    restore_stock_firmware_ui || true

    # Remove HelixScreen patches from screen.sh
    unpatch_forgex_screen_sh || true
    unpatch_forgex_screen_drawing || true

    # Remove logged wrapper
    uninstall_forgex_logged_wrapper || true

    # Re-enable GuppyScreen and tslib init scripts
    if [ -f "/opt/config/mod/.root/S80guppyscreen" ]; then
        $SUDO chmod +x "/opt/config/mod/.root/S80guppyscreen" 2>/dev/null || true
        restored_ui="GuppyScreen (/opt/config/mod/.root/S80guppyscreen)"
    fi
    if [ -f "/opt/config/mod/.root/S35tslib" ]; then
        $SUDO chmod +x "/opt/config/mod/.root/S35tslib" 2>/dev/null || true
    fi

    # Clean up any leftover backup files from manual patches
    for backup_file in /opt/config/mod/.shell/*.helix-backup /opt/config/mod/.shell/*.bak; do
        if [ -f "$backup_file" ] 2>/dev/null; then
            log_info "Removing leftover backup: $backup_file"
            $SUDO rm -f "$backup_file"
        fi
    done
}

# ============================================
# Module: moonraker.sh
# ============================================

#
# Common moonraker.conf locations
MOONRAKER_CONF_PATHS="
/home/pi/printer_data/config/moonraker.conf
/home/biqu/printer_data/config/moonraker.conf
/home/mks/printer_data/config/moonraker.conf
/root/printer_data/config/moonraker.conf
/opt/config/moonraker.conf
/usr/data/printer_data/config/moonraker.conf
"

# Find moonraker.conf
# Returns: path to moonraker.conf or empty string
find_moonraker_conf() {
    # Dynamic: check detected user's home first
    if [ -n "${KLIPPER_HOME:-}" ]; then
        local user_conf="${KLIPPER_HOME}/printer_data/config/moonraker.conf"
        if [ -f "$user_conf" ]; then
            echo "$user_conf"
            return 0
        fi
    fi

    # Static fallback
    for conf in $MOONRAKER_CONF_PATHS; do
        if [ -f "$conf" ]; then
            echo "$conf"
            return 0
        fi
    done
    echo ""
}

# Check if update_manager section for helixscreen already exists
# Args: $1 = moonraker.conf path
# Returns: 0 if exists, 1 if not
has_update_manager_section() {
    local conf="$1"
    grep -q '^\[update_manager helixscreen\]' "$conf" 2>/dev/null
}

# Generate update_manager configuration block
generate_update_manager_config() {
    cat << EOF

# HelixScreen Update Manager
# Added by HelixScreen installer - enables one-click updates from Mainsail/Fluidd
[update_manager helixscreen]
type: zip
channel: stable
repo: prestonbrown/helixscreen
path: ${INSTALL_DIR}
managed_services: helixscreen
persistent_files:
    config/helixconfig.json
    config/.disabled_services
EOF
}

# Add update_manager section to moonraker.conf
# Args: $1 = moonraker.conf path
add_update_manager_section() {
    local conf="$1"
    local fs
    fs=$(file_sudo "$conf")

    # Create backup
    $fs cp "$conf" "${conf}.bak.helixscreen" 2>/dev/null || true

    # Append configuration
    generate_update_manager_config | $fs tee -a "$conf" >/dev/null

    log_success "Added update_manager section to $conf"
    log_info "You can now update HelixScreen from the Mainsail/Fluidd web interface!"
}

# Check if moonraker.conf has old git_repo-style helixscreen section
# Args: $1 = moonraker.conf path
# Returns: 0 if old git_repo section found, 1 if not
has_old_git_repo_section() {
    local conf="$1"
    # Look for helixscreen section with type: git_repo
    if grep -q '^\[update_manager helixscreen\]' "$conf" 2>/dev/null; then
        # Extract the section and check for git_repo type
        awk '/^\[update_manager helixscreen\]/{found=1; next} found && /^\[/{exit} found && /^type:/{print; exit}' "$conf" | grep -q 'git_repo'
        return $?
    fi
    return 1
}

# Migrate old git_repo section to zip
# Args: $1 = moonraker.conf path
migrate_git_repo_to_zip() {
    local conf="$1"

    log_info "Migrating update_manager from git_repo to zip..."

    # Remove old section
    remove_update_manager_section "$conf" 2>/dev/null || true

    # Add new zip section
    add_update_manager_section "$conf"

    # Clean up old sparse clone directory if it exists
    local old_repo_dir="${INSTALL_DIR}-repo"
    if [ -d "$old_repo_dir" ]; then
        log_info "Removing old updater repo at $old_repo_dir..."
        $SUDO rm -rf "$old_repo_dir"
    fi

    log_success "Migrated to type: zip update manager"
}

# Write release_info.json if not already present
# Moonraker type:zip needs this file to detect installed version
write_release_info() {
    local release_info="${INSTALL_DIR}/release_info.json"

    if [ -f "$release_info" ]; then
        return 0
    fi

    # Try to detect version from binary
    local version=""
    if [ -x "${INSTALL_DIR}/bin/helix-screen" ]; then
        version=$("${INSTALL_DIR}/bin/helix-screen" --version 2>/dev/null | head -1 | grep -oE 'v[0-9]+\.[0-9]+\.[0-9]+[^ ]*' || echo "")
    fi

    if [ -z "$version" ]; then
        log_warn "Could not detect version for release_info.json"
        return 0
    fi

    # Determine platform-specific asset name
    local asset_name="helixscreen-pi.zip"
    case "${PLATFORM:-}" in
        pi32)       asset_name="helixscreen-pi32.zip" ;;
        ad5m)       asset_name="helixscreen-ad5m.zip" ;;
        k1)         asset_name="helixscreen-k1.zip" ;;
        k1-dynamic) asset_name="helixscreen-k1-dynamic.zip" ;;
        k2)         asset_name="helixscreen-k2.zip" ;;
    esac

    log_info "Writing release_info.json (${version})..."
    cat > "${release_info}.tmp" << EOF
{"project_name":"helixscreen","project_owner":"prestonbrown","version":"${version}","asset_name":"${asset_name}"}
EOF
    $SUDO mv "${release_info}.tmp" "$release_info"
}

# Ensure helixscreen is in moonraker.asvc (service allowlist)
# Moonraker requires services to be listed here before it can manage them.
# The asvc file lives in printer_data/, one level up from config/moonraker.conf.
# Args: $1 = moonraker.conf path (used to derive printer_data path)
ensure_moonraker_asvc() {
    local conf="$1"
    # printer_data is two levels up from config/moonraker.conf
    local printer_data
    printer_data="$(dirname "$(dirname "$conf")")"
    local asvc="${printer_data}/moonraker.asvc"

    if [ ! -f "$asvc" ]; then
        log_info "No moonraker.asvc found at $asvc, skipping"
        return 0
    fi

    if grep -q '^helixscreen$' "$asvc" 2>/dev/null; then
        return 0
    fi

    local fs
    fs=$(file_sudo "$asvc")
    log_info "Adding helixscreen to $asvc..."
    echo "helixscreen" | $fs tee -a "$asvc" >/dev/null
    log_success "Added helixscreen to Moonraker service allowlist"
}

# Restart Moonraker to pick up configuration changes
restart_moonraker() {
    if command -v systemctl >/dev/null 2>&1 && $SUDO systemctl is-active --quiet moonraker 2>/dev/null; then
        log_info "Restarting Moonraker to apply configuration..."
        $SUDO systemctl restart moonraker || true
    elif [ -x "/etc/init.d/S56moonraker_service" ]; then
        # K1/Simple AF uses SysV init
        log_info "Restarting Moonraker to apply configuration..."
        if ! $SUDO /etc/init.d/S56moonraker_service restart 2>/dev/null; then
            log_warn "Could not restart Moonraker - you may need to restart it manually"
        fi
    fi
}

# Configure Moonraker update_manager
# Called during installation on platforms with web UI (Pi, K1 with Simple AF)
configure_moonraker_updates() {
    local platform=$1

    # Skip on AD5M (typically no Mainsail/Fluidd web UI)
    if [ "$platform" = "ad5m" ]; then
        log_info "Skipping Moonraker update_manager on AD5M (typically no web UI)"
        return 0
    fi

    log_info "Configuring Moonraker update_manager..."

    # Write release_info.json if not already present (fallback for older tarballs)
    write_release_info

    local conf
    conf=$(find_moonraker_conf)

    if [ -z "$conf" ]; then
        log_warn "Could not find moonraker.conf"
        log_warn "To enable web UI updates, manually add to your moonraker.conf:"
        echo ""
        generate_update_manager_config
        echo ""
        return 0
    fi

    # Migrate old git_repo config to zip
    if has_old_git_repo_section "$conf"; then
        migrate_git_repo_to_zip "$conf"
        ensure_moonraker_asvc "$conf"
        restart_moonraker
        return 0
    fi

    if has_update_manager_section "$conf"; then
        log_info "update_manager section already exists in $conf"
        # Still ensure asvc is correct even if section already exists
        ensure_moonraker_asvc "$conf"
        return 0
    fi

    add_update_manager_section "$conf"
    ensure_moonraker_asvc "$conf"
    restart_moonraker
}

# Remove update_manager section from moonraker.conf
# Called during uninstallation
remove_update_manager_section() {
    local conf
    conf=$(find_moonraker_conf)

    if [ -z "$conf" ]; then
        return 0
    fi

    if ! has_update_manager_section "$conf"; then
        return 0
    fi

    log_info "Removing update_manager section from $conf..."

    # Create backup
    local fs
    fs=$(file_sudo "$conf")
    $fs cp "$conf" "${conf}.bak.helixscreen-uninstall" 2>/dev/null || true

    # Remove the section (from [update_manager helixscreen] to next section or EOF)
    # This uses awk to skip lines between [update_manager helixscreen] and the next [section]
    $fs sh -c "awk '
        /^\[update_manager helixscreen\]/ { skip=1; next }
        /^\[/ { skip=0 }
        !skip { print }
    ' \"$conf\" > \"${conf}.tmp\"" && $fs mv "${conf}.tmp" "$conf"

    # Also remove any "Added by HelixScreen" comment lines that precede it
    $fs sed -i '/# HelixScreen Update Manager/d' "$conf" 2>/dev/null || \
    $fs sed -i '' '/# HelixScreen Update Manager/d' "$conf" 2>/dev/null || true

    $fs sed -i '/# Added by HelixScreen installer/d' "$conf" 2>/dev/null || \
    $fs sed -i '' '/# Added by HelixScreen installer/d' "$conf" 2>/dev/null || true

    log_success "Removed update_manager section from $conf"
}

# ============================================
# Module: uninstall.sh
# ============================================

#
# Re-enable services that were disabled during installation
# Reads the state file and reverses each recorded disable action
reenable_disabled_services() {
    local state_file="${INSTALL_DIR}/config/.disabled_services"
    [ -f "$state_file" ] || return 0

    log_info "Re-enabling previously disabled services..."
    while IFS= read -r entry; do
        # Skip empty lines and comments
        case "$entry" in ""|\#*) continue ;; esac

        local type="${entry%%:*}"
        local target="${entry#*:}"

        case "$type" in
            systemd)
                log_info "Re-enabling systemd service: $target"
                $SUDO systemctl enable "$target" 2>/dev/null || true
                ;;
            sysv-chmod)
                if [ -f "$target" ]; then
                    log_info "Re-enabling init script: $target"
                    $SUDO chmod +x "$target" 2>/dev/null || true
                fi
                ;;
        esac
    done < "$state_file"
}

# Uninstall HelixScreen
# Args: platform (optional)
uninstall() {
    local platform=${1:-}

    log_info "Uninstalling HelixScreen..."

    # Detect init system first
    detect_init_system

    if [ "$INIT_SYSTEM" = "systemd" ]; then
        # Stop and disable systemd service
        $SUDO systemctl stop "$SERVICE_NAME" 2>/dev/null || true
        $SUDO systemctl disable "$SERVICE_NAME" 2>/dev/null || true
        $SUDO rm -f "/etc/systemd/system/${SERVICE_NAME}.service"
        $SUDO systemctl daemon-reload
    else
        # Stop and remove SysV init scripts (check all possible locations)
        for init_script in $HELIX_INIT_SCRIPTS; do
            if [ -f "$init_script" ]; then
                log_info "Stopping and removing $init_script..."
                $SUDO "$init_script" stop 2>/dev/null || true
                $SUDO rm -f "$init_script"
            fi
        done
    fi

    # Kill any remaining processes (watchdog first to prevent crash dialog flash)
    # shellcheck disable=SC2086
    kill_process_by_name $HELIX_PROCESSES

    # Clean up PID files and log file
    $SUDO rm -f /var/run/helixscreen.pid 2>/dev/null || true
    $SUDO rm -f /var/run/helix-splash.pid 2>/dev/null || true
    rm -f /tmp/helixscreen.log 2>/dev/null || true

    # Re-enable services from state file (before removing install dir)
    reenable_disabled_services

    # Remove installation (check all possible locations)
    local removed_dir=""
    for install_dir in $HELIX_INSTALL_DIRS; do
        if [ -d "$install_dir" ]; then
            $SUDO rm -rf "$install_dir"
            log_success "Removed ${install_dir}"
            removed_dir="$install_dir"
            # Also remove the updater repo clone if present
            if [ -d "${install_dir}-repo" ]; then
                $SUDO rm -rf "${install_dir}-repo"
                log_success "Removed ${install_dir}-repo"
            fi
        fi
    done

    if [ -z "$removed_dir" ]; then
        log_warn "No HelixScreen installation found"
    fi

    # Re-enable the previous UI based on firmware
    log_info "Re-enabling previous screen UI..."
    local restored_ui=""
    local restored_xorg=""

    if [ "$AD5M_FIRMWARE" = "klipper_mod" ] || [ -f "/etc/init.d/S80klipperscreen" ]; then
        # Klipper Mod - restore Xorg and KlipperScreen
        if [ -f "/etc/init.d/S40xorg" ]; then
            $SUDO chmod +x "/etc/init.d/S40xorg" 2>/dev/null || true
            restored_xorg="Xorg (/etc/init.d/S40xorg)"
        fi
        if [ -f "/etc/init.d/S80klipperscreen" ]; then
            $SUDO chmod +x "/etc/init.d/S80klipperscreen" 2>/dev/null || true
            restored_ui="KlipperScreen (/etc/init.d/S80klipperscreen)"
        fi
    fi

    # Check for K1/Simple AF GuppyScreen
    if [ -z "$restored_ui" ] && [ -f "/etc/init.d/S99guppyscreen" ]; then
        $SUDO chmod +x "/etc/init.d/S99guppyscreen" 2>/dev/null || true
        restored_ui="GuppyScreen (/etc/init.d/S99guppyscreen)"
    fi

    # ForgeX - restore GuppyScreen and stock UI settings
    if [ -z "$restored_ui" ] && [ "$AD5M_FIRMWARE" = "forge_x" ]; then
        uninstall_forgex
    fi

    # Clean up helixscreen cache directories
    for cache_dir in /root/.cache/helix /tmp/helix_thumbs /.cache/helix /data/helixscreen/cache /usr/data/helixscreen/cache; do
        if [ -d "$cache_dir" ] 2>/dev/null; then
            log_info "Removing cache: $cache_dir"
            $(file_sudo "$cache_dir") rm -rf "$cache_dir"
        fi
    done
    # Clean up /var/tmp helix files
    for tmp_pattern in /var/tmp/helix_*; do
        if [ -e "$tmp_pattern" ] 2>/dev/null; then
            log_info "Removing cache: $tmp_pattern"
            $(file_sudo "$tmp_pattern") rm -rf "$tmp_pattern"
        fi
    done

    # Clean up active flag file
    rm -f /tmp/helixscreen_active 2>/dev/null || true

    # Clean up macOS resource fork files (created by scp from Mac)
    for pattern in /opt/._helixscreen /root/._helixscreen; do
        $(file_sudo "$pattern") rm -f "$pattern" 2>/dev/null || true
    done

    # Remove update_manager section from moonraker.conf (if present)
    if type remove_update_manager_section >/dev/null 2>&1; then
        remove_update_manager_section || true
    fi

    log_success "HelixScreen uninstalled"
    if [ -n "$restored_xorg" ]; then
        log_info "Re-enabled: $restored_xorg"
    fi
    if [ -n "$restored_ui" ]; then
        log_info "Re-enabled: $restored_ui"
        log_info "Reboot to start the previous UI"
    else
        log_info "Note: No previous UI found to restore"
    fi
}

# Clean up old installation completely (for --clean flag)
# Removes all files, config, and caches without backup
# Args: platform
clean_old_installation() {
    local platform=$1

    log_warn "=========================================="
    log_warn "  CLEAN INSTALL MODE"
    log_warn "=========================================="
    log_warn ""
    log_warn "This will PERMANENTLY DELETE:"
    log_warn "  - All HelixScreen files in ${INSTALL_DIR}"
    log_warn "  - Your configuration (helixconfig.json)"
    log_warn "  - Thumbnail cache files"
    log_warn ""

    # Interactive confirmation if stdin is a terminal
    if [ -t 0 ]; then
        printf "Are you sure? [y/N] "
        read -r response
        case "$response" in
            [yY][eE][sS]|[yY])
                ;;
            *)
                log_info "Clean install cancelled."
                exit 0
                ;;
        esac
    fi

    log_info "Cleaning old installation..."

    # Stop any running services
    stop_service

    # Remove installation directories (check all possible locations)
    for install_dir in $HELIX_INSTALL_DIRS; do
        if [ -d "$install_dir" ]; then
            log_info "Removing $install_dir..."
            $SUDO rm -rf "$install_dir"
        fi
    done

    # Remove thumbnail caches (POSIX-compatible: no arrays)
    for cache_pattern in \
        "/root/.cache/helix/helix_thumbs" \
        "/home/*/.cache/helix/helix_thumbs" \
        "/tmp/helix_thumbs" \
        "/var/tmp/helix_thumbs" \
        "/var/tmp/helix_*" \
        "/data/helixscreen/cache" \
        "/usr/data/helixscreen/cache"
    do
        for cache_dir in $cache_pattern; do
            if [ -d "$cache_dir" ] 2>/dev/null; then
                log_info "Removing cache: $cache_dir"
                $SUDO rm -rf "$cache_dir"
            fi
        done
    done

    # Remove init scripts (check all possible locations)
    for init_script in $HELIX_INIT_SCRIPTS; do
        if [ -f "$init_script" ]; then
            log_info "Removing init script: $init_script"
            $SUDO rm -f "$init_script"
        fi
    done

    # Remove systemd service if present
    if [ -f "/etc/systemd/system/${SERVICE_NAME}.service" ]; then
        log_info "Removing systemd service..."
        $SUDO systemctl disable "$SERVICE_NAME" 2>/dev/null || true
        $SUDO rm -f "/etc/systemd/system/${SERVICE_NAME}.service"
        $SUDO systemctl daemon-reload 2>/dev/null || true
    fi

    log_success "Old installation cleaned"
    echo ""
}

# ============================================
# Main orchestration
# ============================================

# Re-enable previous UI (extended version with scanning)
reenable_previous_ui() {
    log_info "Looking for previous screen UI to re-enable..."

    found_ui=false
    restored_xorg=false

    # For ForgeX firmware, do comprehensive cleanup and restore
    if [ "$AD5M_FIRMWARE" = "forge_x" ]; then
        uninstall_forgex

        if [ -n "$restored_ui" ]; then
            found_ui=true
        fi
    fi

    # For K1/Simple AF, check for GuppyScreen
    if [ "$platform" = "k1" ]; then
        for k1_ui in /etc/init.d/S99guppyscreen /etc/init.d/S50guppyscreen; do
            if [ -f "$k1_ui" ]; then
                log_info "Re-enabling GuppyScreen for K1..."
                $SUDO chmod +x "$k1_ui" 2>/dev/null || true
                if "$k1_ui" start 2>/dev/null; then
                    log_success "Re-enabled and started: $k1_ui"
                    found_ui=true
                    break
                fi
            fi
        done
    fi

    # For Klipper Mod, re-enable Xorg first (required for KlipperScreen)
    if [ "$AD5M_FIRMWARE" = "klipper_mod" ] || [ -f "/etc/init.d/S40xorg" ]; then
        if [ -f "/etc/init.d/S40xorg" ]; then
            log_info "Re-enabling Xorg display server..."
            $SUDO chmod +x "/etc/init.d/S40xorg" 2>/dev/null || true
            restored_xorg=true
        fi
    fi

    # Try the specific previous UI script for this firmware
    if [ -n "$PREVIOUS_UI_SCRIPT" ] && [ -f "$PREVIOUS_UI_SCRIPT" ]; then
        log_info "Found previous UI: $PREVIOUS_UI_SCRIPT"
        $SUDO chmod +x "$PREVIOUS_UI_SCRIPT" 2>/dev/null || true
        if "$PREVIOUS_UI_SCRIPT" start 2>/dev/null; then
            log_success "Re-enabled and started: $PREVIOUS_UI_SCRIPT"
            found_ui=true
        else
            log_warn "Re-enabled but failed to start: $PREVIOUS_UI_SCRIPT"
            log_warn "You may need to reboot"
            found_ui=true
        fi
    fi

    # Scan for other UIs we might have disabled
    for ui in $PREVIOUS_UIS; do
        for initscript in /etc/init.d/S*${ui}* /opt/config/mod/.root/S*${ui}*; do
            [ "$initscript" = "$PREVIOUS_UI_SCRIPT" ] && continue
            if [ -f "$initscript" ] 2>/dev/null; then
                log_info "Found previous UI: $initscript"
                $SUDO chmod +x "$initscript" 2>/dev/null || true
                if [ "$found_ui" = false ]; then
                    if "$initscript" start 2>/dev/null; then
                        log_success "Re-enabled and started: $initscript"
                        found_ui=true
                    else
                        log_warn "Re-enabled but failed to start: $initscript"
                        log_warn "You may need to reboot"
                        found_ui=true
                    fi
                else
                    log_info "Re-enabled: $initscript (not started, another UI already running)"
                fi
            fi
        done

        if [ "$INIT_SYSTEM" = "systemd" ]; then
            if systemctl list-unit-files "${ui}.service" >/dev/null 2>&1; then
                log_info "Found previous UI (systemd): $ui"
                $SUDO systemctl enable "$ui" 2>/dev/null || true
                if $SUDO systemctl start "$ui" 2>/dev/null; then
                    log_success "Re-enabled and started: $ui"
                    found_ui=true
                else
                    log_warn "Re-enabled but failed to start: $ui"
                    found_ui=true
                fi
            fi
        fi
    done

    # Re-enable tslib for ForgeX (if not already handled by uninstall_forgex)
    if [ -f "/opt/config/mod/.root/S35tslib" ]; then
        $SUDO chmod +x "/opt/config/mod/.root/S35tslib" 2>/dev/null || true
    fi

    if [ "$found_ui" = false ]; then
        log_info "No previous screen UI found to re-enable"
        log_info "If you had a stock UI, a reboot may restore it"
    fi

    if [ "$restored_xorg" = true ]; then
        log_info "Re-enabled: Xorg (/etc/init.d/S40xorg)"
    fi
}

# Stop HelixScreen processes and service
stop_helixscreen() {
    log_info "Stopping HelixScreen..."

    # Stop via init system
    if [ "$INIT_SYSTEM" = "systemd" ]; then
        $SUDO systemctl stop helixscreen 2>/dev/null || true
        $SUDO systemctl disable helixscreen 2>/dev/null || true
    fi

    # Stop via configured init script
    if [ -n "$INIT_SCRIPT_DEST" ] && [ -x "$INIT_SCRIPT_DEST" ]; then
        $SUDO "$INIT_SCRIPT_DEST" stop 2>/dev/null || true
    fi

    # Also check all possible init script locations
    for init_script in $HELIX_INIT_SCRIPTS; do
        if [ -x "$init_script" ]; then
            $SUDO "$init_script" stop 2>/dev/null || true
        fi
    done

    # Kill any remaining processes (watchdog first to prevent crash dialog flash)
    # shellcheck disable=SC2086
    kill_process_by_name $HELIX_PROCESSES || true

    log_success "HelixScreen stopped"
}

# Remove init script or systemd service
remove_service() {
    log_info "Removing service configuration..."

    if [ "$INIT_SYSTEM" = "systemd" ]; then
        if [ -f "/etc/systemd/system/helixscreen.service" ]; then
            $SUDO rm -f "/etc/systemd/system/helixscreen.service"
            $SUDO systemctl daemon-reload
            log_success "Removed systemd service"
        fi
    fi

    # Remove configured init script
    if [ -n "$INIT_SCRIPT_DEST" ] && [ -f "$INIT_SCRIPT_DEST" ]; then
        $SUDO rm -f "$INIT_SCRIPT_DEST"
        log_success "Removed SysV init script: $INIT_SCRIPT_DEST"
    fi

    # Also check and remove from all possible locations
    for init_script in $HELIX_INIT_SCRIPTS; do
        if [ -f "$init_script" ]; then
            $SUDO rm -f "$init_script"
            log_success "Removed SysV init script: $init_script"
        fi
    done
}

# Remove installation directory
remove_installation() {
    log_info "Removing installation..."

    removed_any=false

    # Re-enable services from state file BEFORE removing install dir
    reenable_disabled_services

    # Remove from configured location
    if [ -d "$INSTALL_DIR" ]; then
        $SUDO rm -rf "$INSTALL_DIR"
        log_success "Removed $INSTALL_DIR"
        removed_any=true
        # Also remove updater repo clone if present
        if [ -d "${INSTALL_DIR}-repo" ]; then
            $SUDO rm -rf "${INSTALL_DIR}-repo"
            log_success "Removed ${INSTALL_DIR}-repo"
        fi
    fi

    # Also check and remove from all possible locations
    for install_dir in $HELIX_INSTALL_DIRS; do
        if [ -d "$install_dir" ] && [ "$install_dir" != "$INSTALL_DIR" ]; then
            $SUDO rm -rf "$install_dir"
            log_success "Removed $install_dir"
            removed_any=true
            if [ -d "${install_dir}-repo" ]; then
                $SUDO rm -rf "${install_dir}-repo"
                log_success "Removed ${install_dir}-repo"
            fi
        fi
    done

    if [ "$removed_any" = false ]; then
        log_warn "No HelixScreen installation found (already removed?)"
    fi

    # Clean up PID files, log file, and active flag
    $SUDO rm -f /var/run/helixscreen.pid 2>/dev/null || true
    $SUDO rm -f /var/run/helix-splash.pid 2>/dev/null || true
    $SUDO rm -f /tmp/helixscreen.log 2>/dev/null || true
    $SUDO rm -f /tmp/helixscreen_active 2>/dev/null || true

    # Clean up cache directories
    for cache_dir in /root/.cache/helix /tmp/helix_thumbs /.cache/helix; do
        if [ -d "$cache_dir" ] 2>/dev/null; then
            log_info "Removing cache: $cache_dir"
            $SUDO rm -rf "$cache_dir"
        fi
    done

    # Clean up macOS resource fork files (created by scp from Mac)
    for pattern in /opt/._helixscreen /root/._helixscreen; do
        $SUDO rm -f "$pattern" 2>/dev/null || true
    done
}

# Main uninstall
main() {
    force=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --force|-f)
                force=true
                shift
                ;;
            --help|-h)
                echo "HelixScreen Uninstaller"
                echo ""
                echo "Usage: $0 [options]"
                echo ""
                echo "Options:"
                echo "  --force, -f   Skip confirmation prompt"
                echo "  --help, -h    Show this help message"
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done

    echo ""
    echo "${CYAN}========================================${NC}"
    echo "${CYAN}     HelixScreen Uninstaller${NC}"
    echo "${CYAN}========================================${NC}"
    echo ""

    # Detect platform and firmware to set correct paths
    platform=$(detect_platform)
    if [ "$platform" = "ad5m" ]; then
        AD5M_FIRMWARE=$(detect_ad5m_firmware)
        log_info "Detected AD5M firmware: $AD5M_FIRMWARE"
    fi
    set_install_paths "$platform" "$AD5M_FIRMWARE"

    # Check for root
    check_permissions "$platform"

    # Detect init system
    detect_init_system

    # Confirm unless --force
    if [ "$force" = false ]; then
        echo "This will:"
        echo "  - Stop HelixScreen"
        echo "  - Remove $INSTALL_DIR"
        echo "  - Remove service configuration"
        echo "  - Re-enable previous screen UI (if found)"
        if [ "$AD5M_FIRMWARE" = "forge_x" ]; then
            echo "  - Restore ForgeX display configuration (GuppyScreen)"
        fi
        echo ""
        printf "Are you sure you want to continue? [y/N] "
        read -r response
        case "$response" in
            [yY][eE][sS]|[yY])
                ;;
            *)
                log_info "Uninstall cancelled"
                exit 0
                ;;
        esac
        echo ""
    fi

    # Perform uninstall
    stop_helixscreen
    remove_service
    remove_installation
    reenable_previous_ui
    remove_update_manager_section || true

    echo ""
    echo "${GREEN}========================================${NC}"
    echo "${GREEN}    Uninstall Complete!${NC}"
    echo "${GREEN}========================================${NC}"
    echo ""
    log_info "HelixScreen has been removed."
    log_info "A reboot is recommended to ensure clean state."
    echo ""
}

# Only run when executed directly (not when sourced for testing)
case "${0##*/}" in
    uninstall.sh) main "$@" ;;
esac
