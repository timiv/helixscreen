#!/bin/sh
# Copyright (C) 2025-2026 356C LLC
# SPDX-License-Identifier: GPL-3.0-or-later
#
# HelixScreen Installer (Bundled Version)
# This file is auto-generated by bundle-installer.sh
#
# Usage:
#   curl -sSL https://raw.githubusercontent.com/prestonbrown/helixscreen/main/scripts/install-bundled.sh | sh
#
# Or download and run:
#   wget https://raw.githubusercontent.com/prestonbrown/helixscreen/main/scripts/install-bundled.sh
#   chmod +x install-bundled.sh
#   ./install-bundled.sh
#
# Options:
#   --update    Update existing installation (preserves config)
#   --uninstall Remove HelixScreen
#   --clean     Remove old installation completely before installing (no config backup)
#   --version   Specify version (default: latest)
#

# Mark as bundled installer (modules check this to skip sourcing)
_HELIX_BUNDLED_INSTALLER=1

# Fail fast on any error
set -eu

# Configuration
GITHUB_REPO="prestonbrown/helixscreen"
SERVICE_NAME="helixscreen"


# ============================================
# Module: common.sh
# ============================================

#
# Default configuration (can be overridden before sourcing)
: "${GITHUB_REPO:=prestonbrown/helixscreen}"
: "${INSTALL_DIR:=/opt/helixscreen}"

# Track what we've done for cleanup
CLEANUP_TMP=false
CLEANUP_SERVICE=false
BACKUP_CONFIG=""
ORIGINAL_INSTALL_EXISTS=false

# Colors (if terminal supports it)
setup_colors() {
    if [ -t 1 ]; then
        RED='\033[0;31m'
        GREEN='\033[0;32m'
        YELLOW='\033[1;33m'
        CYAN='\033[0;36m'
        BOLD='\033[1m'
        NC='\033[0m'
    else
        RED=''
        GREEN=''
        YELLOW=''
        CYAN=''
        BOLD=''
        NC=''
    fi
}

# Initialize colors immediately
setup_colors

# Logging functions
log_info() { echo "${CYAN}[INFO]${NC} $1"; }
log_success() { echo "${GREEN}[OK]${NC} $1"; }
log_warn() { echo "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo "${RED}[ERROR]${NC} $1" >&2; }

# Error handler - cleanup and report what went wrong
# Usage: trap 'error_handler $LINENO' ERR
error_handler() {
    local exit_code=$?
    local line_no=$1

    echo ""
    log_error "=========================================="
    log_error "Installation FAILED at line $line_no"
    log_error "Exit code: $exit_code"
    log_error "=========================================="
    echo ""

    # Cleanup temporary files
    if [ "$CLEANUP_TMP" = true ] && [ -d "$TMP_DIR" ]; then
        log_info "Cleaning up temporary files..."
        rm -rf "$TMP_DIR"
    fi

    # If we backed up config and install failed, try to restore state
    if [ -n "$BACKUP_CONFIG" ] && [ -f "$BACKUP_CONFIG" ]; then
        log_info "Restoring backed up configuration..."
        if $SUDO mkdir -p "${INSTALL_DIR}/config" 2>/dev/null; then
            if $SUDO cp "$BACKUP_CONFIG" "${INSTALL_DIR}/config/helixconfig.json" 2>/dev/null; then
                log_success "Configuration restored"
            else
                log_warn "Could not restore config. Backup saved at: $BACKUP_CONFIG"
            fi
        else
            log_warn "Could not create config directory. Backup saved at: $BACKUP_CONFIG"
        fi
    fi

    echo ""
    log_error "Installation was NOT completed."
    log_error "Your system should be in its original state."
    echo ""
    log_info "For help, please:"
    log_info "  1. Check the error message above"
    log_info "  2. Verify network connectivity"
    log_info "  3. Report issues at: https://github.com/${GITHUB_REPO}/issues"
    echo ""

    exit $exit_code
}

# Cleanup function for normal exit
cleanup_on_success() {
    if [ -d "$TMP_DIR" ]; then
        rm -rf "$TMP_DIR"
    fi
}

# ============================================
# Module: platform.sh
# ============================================

#
# Default paths (may be overridden by set_install_paths)
: "${INSTALL_DIR:=/opt/helixscreen}"
: "${TMP_DIR:=/tmp/helixscreen-install}"
INIT_SCRIPT_DEST=""
PREVIOUS_UI_SCRIPT=""
AD5M_FIRMWARE=""
K1_FIRMWARE=""

# Detect platform
# Returns: "ad5m", "k1", "pi", or "unsupported"
detect_platform() {
    local arch kernel
    arch=$(uname -m)
    kernel=$(uname -r)

    # Check for AD5M (armv7l with specific kernel)
    if [ "$arch" = "armv7l" ]; then
        # AD5M has a specific kernel identifier
        if echo "$kernel" | grep -q "ad5m\|5.4.61"; then
            echo "ad5m"
            return
        fi
    fi

    # Check for Creality K1 series (Simple AF or stock with Klipper)
    # K1 uses buildroot and has /usr/data structure
    if [ -f /etc/os-release ] && grep -q "buildroot" /etc/os-release 2>/dev/null; then
        # Buildroot-based system - check for K1 indicators
        if [ -d "/usr/data" ]; then
            # Check for K1-specific indicators (require at least 2 for confidence)
            # - get_sn_mac.sh is a Creality-specific script
            # - /usr/data/pellcorp is Simple AF
            # - /usr/data/printer_data with klipper is a strong K1 indicator
            local k1_indicators=0
            [ -x "/usr/bin/get_sn_mac.sh" ] && k1_indicators=$((k1_indicators + 1))
            [ -d "/usr/data/pellcorp" ] && k1_indicators=$((k1_indicators + 1))
            [ -d "/usr/data/printer_data" ] && k1_indicators=$((k1_indicators + 1))
            [ -d "/usr/data/klipper" ] && k1_indicators=$((k1_indicators + 1))
            # Also check for Creality-specific paths
            [ -f "/usr/data/creality/userdata/config/system_config.json" ] && k1_indicators=$((k1_indicators + 1))

            if [ "$k1_indicators" -ge 2 ]; then
                echo "k1"
                return
            fi
        fi
    fi

    # Check for Raspberry Pi (aarch64 or armv7l)
    if [ "$arch" = "aarch64" ] || [ "$arch" = "armv7l" ]; then
        if [ -f /etc/os-release ] && grep -q "Raspbian\|Debian" /etc/os-release; then
            echo "pi"
            return
        fi
        # Also check for MainsailOS
        if [ -d /home/pi ] || [ -d /home/mks ]; then
            echo "pi"
            return
        fi
    fi

    # Unknown ARM device - don't assume it's a Pi
    # Require explicit platform indicators to avoid false positives
    if [ "$arch" = "aarch64" ] || [ "$arch" = "armv7l" ]; then
        log_warn "Unknown ARM platform. Cannot auto-detect."
        echo "unsupported"
        return
    fi

    echo "unsupported"
}

# Detect AD5M firmware variant (Klipper Mod vs Forge-X)
# Only called when platform is "ad5m"
# Returns: "klipper_mod" or "forge_x"
detect_ad5m_firmware() {
    # Klipper Mod indicators - check for its specific directory structure
    # Klipper Mod runs in a chroot on /mnt/data/.klipper_mod/chroot
    # and puts printer software in /root/printer_software/
    if [ -d "/root/printer_software" ] || [ -d "/mnt/data/.klipper_mod" ]; then
        echo "klipper_mod"
        return
    fi

    # Forge-X indicators - check for its mod overlay structure
    if [ -d "/opt/config/mod/.root" ]; then
        echo "forge_x"
        return
    fi

    # Default to forge_x (original behavior, most common)
    echo "forge_x"
}

# Detect K1 firmware variant (Simple AF vs other)
# Only called when platform is "k1"
# Returns: "simple_af" or "stock_klipper"
detect_k1_firmware() {
    # Simple AF (pellcorp/creality) indicators
    if [ -d "/usr/data/pellcorp" ]; then
        echo "simple_af"
        return
    fi

    # Check for GuppyScreen which Simple AF installs
    if [ -d "/usr/data/guppyscreen" ] && [ -f "/etc/init.d/S99guppyscreen" ]; then
        echo "simple_af"
        return
    fi

    # Default to stock_klipper (generic K1 with Klipper)
    echo "stock_klipper"
}

# Set installation paths based on platform and firmware
# Sets: INSTALL_DIR, INIT_SCRIPT_DEST, PREVIOUS_UI_SCRIPT, TMP_DIR
set_install_paths() {
    local platform=$1
    local firmware=${2:-}

    if [ "$platform" = "ad5m" ]; then
        case "$firmware" in
            klipper_mod)
                INSTALL_DIR="/root/printer_software/helixscreen"
                INIT_SCRIPT_DEST="/etc/init.d/S80helixscreen"
                PREVIOUS_UI_SCRIPT="/etc/init.d/S80klipperscreen"
                # Klipper Mod has small tmpfs (~54MB), package is ~70MB
                # Use /mnt/data which has 4+ GB available
                TMP_DIR="/mnt/data/helixscreen-install"
                log_info "AD5M firmware: Klipper Mod"
                log_info "Install directory: ${INSTALL_DIR}"
                log_info "Using /mnt/data for temp files (tmpfs too small)"
                ;;
            forge_x|*)
                INSTALL_DIR="/opt/helixscreen"
                INIT_SCRIPT_DEST="/etc/init.d/S90helixscreen"
                PREVIOUS_UI_SCRIPT="/opt/config/mod/.root/S80guppyscreen"
                TMP_DIR="/tmp/helixscreen-install"
                log_info "AD5M firmware: Forge-X"
                log_info "Install directory: ${INSTALL_DIR}"
                ;;
        esac
    elif [ "$platform" = "k1" ]; then
        # Creality K1 series - uses /usr/data structure
        case "$firmware" in
            simple_af|*)
                INSTALL_DIR="/usr/data/helixscreen"
                INIT_SCRIPT_DEST="/etc/init.d/S99helixscreen"
                PREVIOUS_UI_SCRIPT="/etc/init.d/S99guppyscreen"
                TMP_DIR="/tmp/helixscreen-install"
                log_info "K1 firmware: Simple AF"
                log_info "Install directory: ${INSTALL_DIR}"
                ;;
        esac
    else
        # Pi and other platforms - use default paths
        INSTALL_DIR="/opt/helixscreen"
        INIT_SCRIPT_DEST="/etc/init.d/S90helixscreen"
        PREVIOUS_UI_SCRIPT=""
        TMP_DIR="/tmp/helixscreen-install"
    fi
}

# ============================================
# Module: permissions.sh
# ============================================

#
# Initialize SUDO (will be set by check_permissions)
SUDO=""
# Check if running as root (required for AD5M/K1, optional for Pi)
# Sets: SUDO variable ("sudo" or "")
check_permissions() {
    local platform=$1

    if [ "$platform" = "ad5m" ] || [ "$platform" = "k1" ]; then
        if [ "$(id -u)" != "0" ]; then
            log_error "Installation on $platform requires root privileges."
            log_error "Please run: sudo $0 $*"
            exit 1
        fi
        SUDO=""
    else
        # Pi: warn if not root but allow sudo
        if [ "$(id -u)" != "0" ]; then
            if ! command -v sudo >/dev/null 2>&1; then
                log_error "Not running as root and sudo is not available."
                log_error "Please run as root or install sudo."
                exit 1
            fi
            log_info "Not running as root. Will use sudo for privileged operations."
            SUDO="sudo"
        else
            SUDO=""
        fi
    fi
}

# ============================================
# Module: requirements.sh
# ============================================

#
# Initialize INIT_SYSTEM (will be set by detect_init_system)
INIT_SYSTEM=""
# Check required commands exist
# Requires: curl or wget, tar, gunzip
check_requirements() {
    local missing=""

    # Need either curl or wget
    if ! command -v curl >/dev/null 2>&1 && ! command -v wget >/dev/null 2>&1; then
        missing="curl or wget"
    fi

    # Need tar
    if ! command -v tar >/dev/null 2>&1; then
        if [ -n "$missing" ]; then
            missing="$missing, tar"
        else
            missing="tar"
        fi
    fi

    # Need gunzip (for AD5M BusyBox tar which doesn't support -z)
    if ! command -v gunzip >/dev/null 2>&1; then
        if [ -n "$missing" ]; then
            missing="$missing, gunzip"
        else
            missing="gunzip"
        fi
    fi

    if [ -n "$missing" ]; then
        log_error "Missing required commands: $missing"
        log_error "Please install them and try again."
        exit 1
    fi

    log_success "All required commands available"
}

# Install runtime dependencies for Pi platform
# Required for DRM display and evdev input handling
# AD5M uses framebuffer with static linking, no deps needed
install_runtime_deps() {
    local platform=$1

    # Only needed for Pi - AD5M uses framebuffer with static linking
    if [ "$platform" != "pi" ]; then
        return 0
    fi

    log_info "Checking runtime dependencies for display/input..."

    # Required libraries for DRM display and libinput
    # Note: GPU libs (libgles2, libegl1, libgbm1) not needed - using software rendering
    local deps="libdrm2 libinput10"
    local missing=""

    for dep in $deps; do
        # Check if package is installed (dpkg-query returns 0 if installed)
        if ! dpkg-query -W -f='${Status}' "$dep" 2>/dev/null | grep -q "install ok installed"; then
            if [ -n "$missing" ]; then
                missing="$missing $dep"
            else
                missing="$dep"
            fi
        fi
    done

    if [ -n "$missing" ]; then
        log_info "Installing missing libraries: $missing"
        $SUDO apt-get update -qq
        # shellcheck disable=SC2086
        $SUDO apt-get install -y --no-install-recommends $missing
        log_success "Runtime libraries installed"
    else
        log_success "All runtime libraries already installed"
    fi
}

# Check available disk space
# Requires at least 50MB free on the install directory's filesystem
# Note: INSTALL_DIR must be set before calling this function
check_disk_space() {
    local platform=$1
    local required_mb=50

    # Get the parent directory of install location (the filesystem to check)
    local check_dir
    check_dir=$(dirname "${INSTALL_DIR:-/opt/helixscreen}")
    # Walk up until we find an existing directory
    while [ ! -d "$check_dir" ] && [ "$check_dir" != "/" ]; do
        check_dir=$(dirname "$check_dir")
    done
    if [ "$check_dir" = "/" ]; then
        check_dir="/"
    fi

    # Get available space in MB
    local available_mb
    if [ "$platform" = "ad5m" ] || [ "$platform" = "k1" ]; then
        # BusyBox df output format: blocks are in KB by default
        available_mb=$(df "$check_dir" 2>/dev/null | tail -1 | awk '{print int($4/1024)}')
    else
        # GNU df with -m flag outputs in MB
        available_mb=$(df -m "$check_dir" 2>/dev/null | tail -1 | awk '{print $4}')
    fi

    if [ -n "$available_mb" ] && [ "$available_mb" -lt "$required_mb" ]; then
        log_error "Insufficient disk space on $check_dir"
        log_error "Required: ${required_mb}MB, Available: ${available_mb}MB"
        exit 1
    fi

    log_info "Disk space check: ${available_mb}MB available on $check_dir"
}

# Detect init system (systemd vs SysV)
# Sets: INIT_SYSTEM to "systemd" or "sysv"
detect_init_system() {
    # Check for systemd
    if command -v systemctl >/dev/null 2>&1 && [ -d /run/systemd/system ]; then
        INIT_SYSTEM="systemd"
        log_info "Init system: systemd"
        return
    fi

    # Check for SysV init (BusyBox or traditional)
    if [ -d /etc/init.d ]; then
        INIT_SYSTEM="sysv"
        log_info "Init system: SysV (BusyBox/traditional)"
        return
    fi

    log_error "Could not detect init system."
    log_error "Neither systemd nor /etc/init.d found."
    exit 1
}

# ============================================
# Module: forgex.sh
# ============================================

#
# Configure ForgeX display settings for HelixScreen
# We use GUPPY mode because ForgeX handles backlight properly in this mode.
# STOCK mode expects ffstartup-arm to manage display/backlight which doesn't work for us.
# We disable GuppyScreen's init scripts so HelixScreen takes over the display.
configure_forgex_display() {
    var_file="/opt/config/mod_data/variables.cfg"
    guppy_init="/opt/config/mod/.root/S80guppyscreen"
    tslib_init="/opt/config/mod/.root/S35tslib"
    changed=false

    # Set display mode to GUPPY (required for backlight to work)
    if [ -f "$var_file" ]; then
        if grep -q "display[[:space:]]*=[[:space:]]*'STOCK'" "$var_file"; then
            log_info "Setting ForgeX display mode to GUPPY..."
            $SUDO sed -i "s/display[[:space:]]*=[[:space:]]*'STOCK'/display = 'GUPPY'/" "$var_file"
            changed=true
        elif grep -q "display[[:space:]]*=[[:space:]]*'HEADLESS'" "$var_file"; then
            log_info "Setting ForgeX display mode to GUPPY..."
            $SUDO sed -i "s/display[[:space:]]*=[[:space:]]*'HEADLESS'/display = 'GUPPY'/" "$var_file"
            changed=true
        fi
    fi

    # Disable GuppyScreen init script (remove execute permission)
    if [ -x "$guppy_init" ]; then
        log_info "Disabling GuppyScreen init script..."
        $SUDO chmod -x "$guppy_init"
        changed=true
    fi

    # Disable tslib init script (GuppyScreen's touch input layer)
    # HelixScreen uses its own input handling
    if [ -x "$tslib_init" ]; then
        log_info "Disabling tslib init script..."
        $SUDO chmod -x "$tslib_init"
        changed=true
    fi

    if [ "$changed" = true ]; then
        log_success "ForgeX configured for HelixScreen (GUPPY mode, GuppyScreen disabled)"
        return 0
    fi
    return 1
}

# Patch ForgeX screen.sh to skip non-100 backlight control when HelixScreen is active
# ForgeX's headless.cfg runs a delayed_gcode that dims the backlight 3 seconds after
# Klipper starts. This patch blocks dimming calls but allows the S99root 0→100 cycle.
#
# The smart patch:
# - Allows "backlight 100" (needed for S99root initialization cycle)
# - Blocks other values (10, 0, etc.) when helixscreen_active flag exists
patch_forgex_screen_sh() {
    screen_sh="/opt/config/mod/.shell/screen.sh"

    if [ ! -f "$screen_sh" ]; then
        log_info "ForgeX screen.sh not found, skipping patch"
        return 1
    fi

    # Check if already patched (look for the smart patch signature)
    if grep -q 'helixscreen_active.*!=.*100' "$screen_sh" 2>/dev/null; then
        log_info "ForgeX screen.sh already has smart patch"
        return 0
    fi

    # Remove old-style patch if present (blocks ALL backlight when flag exists)
    if grep -q "helixscreen_active" "$screen_sh" 2>/dev/null; then
        log_info "Removing old-style patch from screen.sh..."
        tmp_file="${screen_sh}.tmp"
        grep -v "helixscreen_active\|# Skip if HelixScreen" "$screen_sh" > "$tmp_file"
        $SUDO mv "$tmp_file" "$screen_sh"
        $SUDO chmod +x "$screen_sh"
    fi

    # Find the backlight) case and add our guard
    if ! grep -q "^[[:space:]]*backlight)" "$screen_sh"; then
        log_info "Could not find backlight case in screen.sh"
        return 1
    fi

    log_info "Patching ForgeX screen.sh with smart backlight control..."

    # Use awk to insert our check after "backlight)" line (BusyBox compatible)
    # Smart patch: only block non-100 values, allowing S99root's 0→100 init cycle
    tmp_file="${screen_sh}.tmp"
    awk '
    /^[[:space:]]*backlight\)/ {
        print
        print "        # Skip non-100 backlight changes when HelixScreen is controlling display"
        print "        # Allows S99root 0->100 init cycle but blocks Klipper eco dimming"
        print "        if [ -f /tmp/helixscreen_active ] && [ \"$2\" != \"100\" ]; then"
        print "            exit 0"
        print "        fi"
        next
    }
    { print }
    ' "$screen_sh" > "$tmp_file"

    if [ -s "$tmp_file" ] && grep -q 'helixscreen_active.*!=.*100' "$tmp_file" 2>/dev/null; then
        $SUDO mv "$tmp_file" "$screen_sh"
        $SUDO chmod +x "$screen_sh"
        log_success "ForgeX screen.sh patched with smart backlight control"
        return 0
    else
        rm -f "$tmp_file"
        log_warn "Failed to patch ForgeX screen.sh"
        return 1
    fi
}

# Remove HelixScreen patch from ForgeX screen.sh (for uninstall)
unpatch_forgex_screen_sh() {
    screen_sh="/opt/config/mod/.shell/screen.sh"

    if [ ! -f "$screen_sh" ]; then
        return 1
    fi

    # Check if patched
    if ! grep -q "helixscreen_active" "$screen_sh" 2>/dev/null; then
        log_info "ForgeX screen.sh not patched, nothing to remove"
        return 0
    fi

    log_info "Removing HelixScreen patch from ForgeX screen.sh..."

    # Use awk to remove only our specific block (BusyBox compatible)
    # Match and skip: comment line, if line with helixscreen_active, exit 0, fi
    tmp_file="${screen_sh}.tmp"
    awk '
    /# Skip if HelixScreen is controlling the display/ { skip=1; next }
    /if \[ -f \/tmp\/helixscreen_active \]; then/ { skip=1; next }
    skip && /^[[:space:]]*exit 0[[:space:]]*$/ { next }
    skip && /^[[:space:]]*fi[[:space:]]*$/ { skip=0; next }
    { print }
    ' "$screen_sh" > "$tmp_file"

    if [ -s "$tmp_file" ]; then
        $SUDO mv "$tmp_file" "$screen_sh"
        $SUDO chmod +x "$screen_sh"
    else
        rm -f "$tmp_file"
        log_warn "Failed to unpatch ForgeX screen.sh"
        return 1
    fi

    # Verify removal
    if grep -q "helixscreen_active" "$screen_sh" 2>/dev/null; then
        log_warn "Could not fully remove patch from screen.sh"
        return 1
    fi

    log_success "ForgeX screen.sh patch removed"
    return 0
}

# Disable stock FlashForge UI in auto_run.sh
# The stock firmware UI (ffstartup-arm/firmwareExe) is started by /opt/auto_run.sh
# which runs AFTER init scripts. We comment out the line to prevent it starting.
disable_stock_firmware_ui() {
    auto_run="/opt/auto_run.sh"
    if [ -f "$auto_run" ]; then
        # Check if ffstartup-arm line exists and is not already commented
        if grep -q "^/opt/PROGRAM/ffstartup-arm" "$auto_run"; then
            log_info "Disabling stock FlashForge UI in auto_run.sh..."
            # Comment out the ffstartup-arm line
            $SUDO sed -i 's|^/opt/PROGRAM/ffstartup-arm|# Disabled by HelixScreen: /opt/PROGRAM/ffstartup-arm|' "$auto_run"
            log_success "Stock FlashForge UI disabled"
            return 0
        fi
    fi
    return 1
}

# Re-enable stock FlashForge UI in auto_run.sh (for uninstall)
restore_stock_firmware_ui() {
    auto_run="/opt/auto_run.sh"
    if [ -f "$auto_run" ]; then
        # Check if our disabled line exists
        if grep -q "^# Disabled by HelixScreen: /opt/PROGRAM/ffstartup-arm" "$auto_run"; then
            log_info "Re-enabling stock FlashForge UI in auto_run.sh..."
            # Uncomment the ffstartup-arm line
            $SUDO sed -i 's|^# Disabled by HelixScreen: /opt/PROGRAM/ffstartup-arm|/opt/PROGRAM/ffstartup-arm|' "$auto_run"
            log_success "Stock FlashForge UI re-enabled"
            return 0
        fi
    fi
    return 1
}

# ============================================
# Module: competing_uis.sh
# ============================================

#
# Known competing screen UIs to stop
# Includes: GuppyScreen (AD5M/K1), Grumpyscreen (K1/Simple AF), KlipperScreen, FeatherScreen
COMPETING_UIS="guppyscreen GuppyScreen grumpyscreen Grumpyscreen KlipperScreen klipperscreen featherscreen FeatherScreen"

# Stop competing screen UIs (GuppyScreen, KlipperScreen, Xorg, etc.)
stop_competing_uis() {
    log_info "Checking for competing screen UIs..."

    found_any=false

    # Stop stock FlashForge firmware UI (AD5M/Adventurer 5M)
    # ffstartup-arm is the startup manager that launches firmwareExe (the stock Qt UI)
    if [ -f /opt/PROGRAM/ffstartup-arm ]; then
        log_info "Stopping stock FlashForge UI..."
        if command -v killall >/dev/null 2>&1; then
            $SUDO killall firmwareExe 2>/dev/null || true
            $SUDO killall ffstartup-arm 2>/dev/null || true
        elif command -v pidof >/dev/null 2>&1; then
            for pid in $(pidof firmwareExe 2>/dev/null); do
                $SUDO kill "$pid" 2>/dev/null || true
            done
            for pid in $(pidof ffstartup-arm 2>/dev/null); do
                $SUDO kill "$pid" 2>/dev/null || true
            done
        fi
        found_any=true
    fi

    # On Klipper Mod, stop Xorg first (required for framebuffer access)
    # Xorg takes over /dev/fb0 layer, preventing direct framebuffer rendering
    if [ -x "/etc/init.d/S40xorg" ]; then
        log_info "Stopping Xorg (Klipper Mod display server)..."
        $SUDO /etc/init.d/S40xorg stop 2>/dev/null || true
        # Disable Xorg init script (non-destructive, reversible)
        $SUDO chmod -x /etc/init.d/S40xorg 2>/dev/null || true
        # Kill any remaining Xorg processes (BusyBox compatible - no pkill)
        if command -v killall >/dev/null 2>&1; then
            $SUDO killall Xorg 2>/dev/null || true
            $SUDO killall X 2>/dev/null || true
        elif command -v pidof >/dev/null 2>&1; then
            for pid in $(pidof Xorg 2>/dev/null) $(pidof X 2>/dev/null); do
                $SUDO kill "$pid" 2>/dev/null || true
            done
        fi
        found_any=true
    fi

    # First, handle the specific previous UI if we know it (for clean reversibility)
    if [ -n "$PREVIOUS_UI_SCRIPT" ] && [ -x "$PREVIOUS_UI_SCRIPT" ] 2>/dev/null; then
        log_info "Stopping previous UI: $PREVIOUS_UI_SCRIPT"
        $SUDO "$PREVIOUS_UI_SCRIPT" stop 2>/dev/null || true
        # Disable by removing execute permission (non-destructive, reversible)
        $SUDO chmod -x "$PREVIOUS_UI_SCRIPT" 2>/dev/null || true
        found_any=true
    fi

    for ui in $COMPETING_UIS; do
        # Check systemd services
        if [ "$INIT_SYSTEM" = "systemd" ]; then
            if $SUDO systemctl is-active --quiet "$ui" 2>/dev/null; then
                log_info "Stopping $ui (systemd service)..."
                $SUDO systemctl stop "$ui" 2>/dev/null || true
                $SUDO systemctl disable "$ui" 2>/dev/null || true
                found_any=true
            fi
        fi

        # Check SysV init scripts (various locations)
        for initscript in /etc/init.d/S*${ui}* /etc/init.d/${ui}* /opt/config/mod/.root/S*${ui}*; do
            # Skip if glob didn't match any files (literal pattern returned)
            [ -e "$initscript" ] || continue
            # Skip if this is the PREVIOUS_UI_SCRIPT we already handled
            if [ "$initscript" = "$PREVIOUS_UI_SCRIPT" ]; then
                continue
            fi
            if [ -x "$initscript" ]; then
                log_info "Stopping $ui ($initscript)..."
                $SUDO "$initscript" stop 2>/dev/null || true
                # Disable by removing execute permission (non-destructive)
                $SUDO chmod -x "$initscript" 2>/dev/null || true
                found_any=true
            fi
        done

        # Kill any remaining processes by name
        if command -v killall >/dev/null 2>&1; then
            if killall -0 "$ui" 2>/dev/null; then
                log_info "Killing remaining $ui processes..."
                $SUDO killall "$ui" 2>/dev/null || true
                found_any=true
            fi
        elif command -v pidof >/dev/null 2>&1; then
            pids=$(pidof "$ui" 2>/dev/null)
            if [ -n "$pids" ]; then
                log_info "Killing remaining $ui processes..."
                for pid in $pids; do
                    $SUDO kill "$pid" 2>/dev/null || true
                done
                found_any=true
            fi
        fi
    done

    # Also kill python processes running KlipperScreen (common on Klipper Mod)
    # BusyBox ps doesn't support 'aux', use portable approach
    # shellcheck disable=SC2009
    for pid in $(ps -ef 2>/dev/null | grep -E 'KlipperScreen.*screen\.py' | grep -v grep | awk '{print $2}'); do
        log_info "Killing KlipperScreen python process (PID $pid)..."
        $SUDO kill "$pid" 2>/dev/null || true
        found_any=true
    done

    if [ "$found_any" = true ]; then
        log_info "Waiting for competing UIs to stop..."
        sleep 2
    else
        log_info "No competing UIs found"
    fi
}

# ============================================
# Module: release.sh
# ============================================

#
# Get latest release version from GitHub
get_latest_version() {
    local url="https://api.github.com/repos/${GITHUB_REPO}/releases/latest"
    local version=""

    log_info "Fetching latest version from GitHub..."

    if command -v curl >/dev/null 2>&1; then
        version=$(curl -sSL --connect-timeout 10 "$url" 2>/dev/null | grep '"tag_name"' | sed -E 's/.*"([^"]+)".*/\1/')
    elif command -v wget >/dev/null 2>&1; then
        version=$(wget -qO- --timeout=10 "$url" 2>/dev/null | grep '"tag_name"' | sed -E 's/.*"([^"]+)".*/\1/')
    fi

    if [ -z "$version" ]; then
        log_error "Failed to fetch latest version from GitHub."
        log_error "Check your network connection and try again."
        log_error "URL: $url"
        exit 1
    fi

    echo "$version"
}

# Download release tarball
download_release() {
    local version=$1
    local platform=$2

    local filename="helixscreen-${platform}-${version}.tar.gz"
    local url="https://github.com/${GITHUB_REPO}/releases/download/${version}/${filename}"
    local dest="${TMP_DIR}/helixscreen.tar.gz"

    log_info "Downloading HelixScreen ${version} for ${platform}..."
    log_info "URL: $url"

    mkdir -p "$TMP_DIR"
    CLEANUP_TMP=true

    local http_code=""
    if command -v curl >/dev/null 2>&1; then
        http_code=$(curl -sSL --connect-timeout 30 -w "%{http_code}" -o "$dest" "$url")
    elif command -v wget >/dev/null 2>&1; then
        if wget -q --timeout=30 -O "$dest" "$url"; then
            http_code="200"
        else
            http_code="failed"
        fi
    fi

    if [ ! -f "$dest" ] || [ ! -s "$dest" ]; then
        log_error "Failed to download release."
        log_error "URL: $url"
        if [ -n "$http_code" ] && [ "$http_code" != "200" ]; then
            log_error "HTTP status: $http_code"
        fi
        log_error ""
        log_error "Possible causes:"
        log_error "  - Version ${version} may not exist for platform ${platform}"
        log_error "  - Network connectivity issues"
        log_error "  - GitHub may be unavailable"
        exit 1
    fi

    # Verify it's a valid gzip file
    if ! gunzip -t "$dest" 2>/dev/null; then
        log_error "Downloaded file is not a valid gzip archive."
        log_error "The download may have been corrupted or incomplete."
        exit 1
    fi

    # Verify download isn't truncated (releases should be >1MB)
    local size_kb
    size_kb=$(du -k "$dest" 2>/dev/null | cut -f1)
    if [ "${size_kb:-0}" -lt 1024 ]; then
        log_error "Downloaded file too small (${size_kb}KB). Download may be incomplete."
        exit 1
    fi

    local size
    size=$(ls -lh "$dest" | awk '{print $5}')
    log_success "Downloaded ${filename} (${size})"
}

# Extract tarball (handles BusyBox tar on AD5M)
extract_release() {
    local platform=$1
    local tarball="${TMP_DIR}/helixscreen.tar.gz"

    log_info "Extracting release to ${INSTALL_DIR}..."

    # Check if install dir already exists
    if [ -d "${INSTALL_DIR}" ]; then
        ORIGINAL_INSTALL_EXISTS=true

        # Backup existing config (check new location first, then legacy)
        if [ -f "${INSTALL_DIR}/config/helixconfig.json" ]; then
            BACKUP_CONFIG="${TMP_DIR}/helixconfig.json.backup"
            cp "${INSTALL_DIR}/config/helixconfig.json" "$BACKUP_CONFIG"
            log_info "Backed up existing configuration (from config/)"
        elif [ -f "${INSTALL_DIR}/helixconfig.json" ]; then
            BACKUP_CONFIG="${TMP_DIR}/helixconfig.json.backup"
            cp "${INSTALL_DIR}/helixconfig.json" "$BACKUP_CONFIG"
            log_info "Backed up existing configuration (legacy location)"
        fi
    fi

    # Remove old installation
    $SUDO rm -rf "${INSTALL_DIR}"

    # Create parent directory
    $SUDO mkdir -p "$(dirname "${INSTALL_DIR}")"

    # Extract - AD5M and K1 use BusyBox tar which doesn't support -z
    cd "$(dirname "${INSTALL_DIR}")" || exit 1
    if [ "$platform" = "ad5m" ] || [ "$platform" = "k1" ]; then
        if ! gunzip -c "$tarball" | $SUDO tar xf -; then
            log_error "Failed to extract tarball."
            log_error "The archive may be corrupted."
            exit 1
        fi
    else
        if ! $SUDO tar -xzf "$tarball"; then
            log_error "Failed to extract tarball."
            log_error "The archive may be corrupted."
            exit 1
        fi
    fi

    # Verify extraction succeeded
    if [ ! -f "${INSTALL_DIR}/helix-screen" ]; then
        log_error "Extraction failed - helix-screen binary not found."
        log_error "Expected: ${INSTALL_DIR}/helix-screen"
        exit 1
    fi

    # Restore config to new location (config/helixconfig.json)
    if [ -n "$BACKUP_CONFIG" ] && [ -f "$BACKUP_CONFIG" ]; then
        $SUDO mkdir -p "${INSTALL_DIR}/config"
        $SUDO cp "$BACKUP_CONFIG" "${INSTALL_DIR}/config/helixconfig.json"
        log_info "Restored existing configuration to config/"
    fi

    log_success "Extracted to ${INSTALL_DIR}"
}

# ============================================
# Module: service.sh
# ============================================

#
# Default service name
: "${SERVICE_NAME:=helixscreen}"
# Install service (dispatcher)
# Calls install_service_systemd or install_service_sysv based on INIT_SYSTEM
install_service() {
    local platform=$1

    if [ "$INIT_SYSTEM" = "systemd" ]; then
        install_service_systemd
    else
        install_service_sysv
    fi
}

# Install systemd service
install_service_systemd() {
    log_info "Installing systemd service..."

    local service_src="${INSTALL_DIR}/config/helixscreen.service"
    local service_dest="/etc/systemd/system/${SERVICE_NAME}.service"

    if [ ! -f "$service_src" ]; then
        log_error "Service file not found: $service_src"
        log_error "The release package may be incomplete."
        exit 1
    fi

    $SUDO cp "$service_src" "$service_dest"

    if ! $SUDO systemctl daemon-reload; then
        log_error "Failed to reload systemd daemon."
        exit 1
    fi

    CLEANUP_SERVICE=true
    log_success "Installed systemd service"
}

# Install SysV init script
install_service_sysv() {
    log_info "Installing SysV init script..."

    local init_src="${INSTALL_DIR}/config/helixscreen.init"

    if [ ! -f "$init_src" ]; then
        log_error "Init script not found: $init_src"
        log_error "The release package may be incomplete."
        exit 1
    fi

    # Use the dynamically set INIT_SCRIPT_DEST (varies by firmware)
    $SUDO cp "$init_src" "$INIT_SCRIPT_DEST"
    $SUDO chmod +x "$INIT_SCRIPT_DEST"

    # Update the DAEMON_DIR in the init script to match the install location
    # This is important for Klipper Mod which uses a different path
    $SUDO sed -i "s|DAEMON_DIR=.*|DAEMON_DIR=\"${INSTALL_DIR}\"|" "$INIT_SCRIPT_DEST" 2>/dev/null || \
    $SUDO sed -i '' "s|DAEMON_DIR=.*|DAEMON_DIR=\"${INSTALL_DIR}\"|" "$INIT_SCRIPT_DEST" 2>/dev/null || true

    CLEANUP_SERVICE=true
    log_success "Installed SysV init script at $INIT_SCRIPT_DEST"
}

# Start service (dispatcher)
# Calls start_service_systemd or start_service_sysv based on INIT_SYSTEM
start_service() {
    if [ "$INIT_SYSTEM" = "systemd" ]; then
        start_service_systemd
    else
        start_service_sysv
    fi
}

# Start service (systemd)
start_service_systemd() {
    log_info "Enabling and starting HelixScreen (systemd)..."

    if ! $SUDO systemctl enable "$SERVICE_NAME"; then
        log_error "Failed to enable ${SERVICE_NAME} service."
        exit 1
    fi

    if ! $SUDO systemctl start "$SERVICE_NAME"; then
        log_error "Failed to start ${SERVICE_NAME} service."
        log_error "Check logs with: journalctl -u ${SERVICE_NAME} -n 50"
        exit 1
    fi

    # Wait for service to start (may be slow on embedded hardware)
    local i
    for i in 1 2 3 4 5; do
        sleep 1
        if $SUDO systemctl is-active --quiet "$SERVICE_NAME"; then
            log_success "HelixScreen is running!"
            return
        fi
    done
    log_warn "Service may still be starting..."
    log_warn "Check status with: systemctl status $SERVICE_NAME"
}

# Start service (SysV init)
start_service_sysv() {
    log_info "Starting HelixScreen (SysV init)..."

    if [ ! -x "$INIT_SCRIPT_DEST" ]; then
        log_error "Init script not executable: $INIT_SCRIPT_DEST"
        exit 1
    fi

    if ! $SUDO "$INIT_SCRIPT_DEST" start; then
        log_error "Failed to start HelixScreen."
        log_error "Check logs in: /tmp/helixscreen.log"
        exit 1
    fi

    # Wait for service to start (may be slow on embedded hardware)
    local i
    for i in 1 2 3 4 5; do
        sleep 1
        if $SUDO "$INIT_SCRIPT_DEST" status >/dev/null 2>&1; then
            log_success "HelixScreen is running!"
            return
        fi
    done
    log_warn "Service may still be starting..."
    log_warn "Check: $INIT_SCRIPT_DEST status"
}

# Stop service for update
stop_service() {
    if [ "$INIT_SYSTEM" = "systemd" ]; then
        if $SUDO systemctl is-active --quiet "$SERVICE_NAME" 2>/dev/null; then
            log_info "Stopping existing HelixScreen service (systemd)..."
            $SUDO systemctl stop "$SERVICE_NAME" || true
        fi
    else
        # Try the configured init script location first
        if [ -n "$INIT_SCRIPT_DEST" ] && [ -x "$INIT_SCRIPT_DEST" ]; then
            log_info "Stopping existing HelixScreen service (SysV)..."
            $SUDO "$INIT_SCRIPT_DEST" stop 2>/dev/null || true
        fi
        # Also check all possible locations (for updates/uninstalls)
        for init_script in /etc/init.d/S80helixscreen /etc/init.d/S90helixscreen /etc/init.d/S99helixscreen; do
            if [ -x "$init_script" ]; then
                log_info "Stopping HelixScreen at $init_script..."
                $SUDO "$init_script" stop 2>/dev/null || true
            fi
        done
        # Also try to kill by name (watchdog first to prevent crash dialog flash)
        if command -v killall >/dev/null 2>&1; then
            $SUDO killall helix-watchdog 2>/dev/null || true
            $SUDO killall helix-screen 2>/dev/null || true
            $SUDO killall helix-splash 2>/dev/null || true
        fi
    fi
}

# ============================================
# Module: moonraker.sh
# ============================================

#
# Common moonraker.conf locations
MOONRAKER_CONF_PATHS="
/home/pi/printer_data/config/moonraker.conf
/home/mks/printer_data/config/moonraker.conf
/root/printer_data/config/moonraker.conf
/opt/config/moonraker.conf
/usr/data/printer_data/config/moonraker.conf
"

# Find moonraker.conf
# Returns: path to moonraker.conf or empty string
find_moonraker_conf() {
    for conf in $MOONRAKER_CONF_PATHS; do
        if [ -f "$conf" ]; then
            echo "$conf"
            return 0
        fi
    done
    echo ""
}

# Check if update_manager section for helixscreen already exists
# Args: $1 = moonraker.conf path
# Returns: 0 if exists, 1 if not
has_update_manager_section() {
    local conf="$1"
    grep -q '^\[update_manager helixscreen\]' "$conf" 2>/dev/null
}

# Generate update_manager configuration block
# Uses git_repo type for tracking updates
# Note: Uses INSTALL_DIR which must be set before calling
generate_update_manager_config() {
    cat << EOF

# HelixScreen Update Manager
# Added by HelixScreen installer - enables one-click updates from Mainsail/Fluidd
[update_manager helixscreen]
type: git_repo
channel: stable
path: ${INSTALL_DIR}
origin: https://github.com/prestonbrown/helixscreen.git
primary_branch: main
managed_services: helixscreen
install_script: scripts/install.sh
EOF
}

# Add update_manager section to moonraker.conf
# Args: $1 = moonraker.conf path
add_update_manager_section() {
    local conf="$1"

    # Create backup
    $SUDO cp "$conf" "${conf}.bak.helixscreen" 2>/dev/null || true

    # Append configuration
    generate_update_manager_config | $SUDO tee -a "$conf" >/dev/null

    log_success "Added update_manager section to $conf"
    log_info "You can now update HelixScreen from the Mainsail/Fluidd web interface!"
}

# Configure Moonraker update_manager
# Called during installation on platforms with web UI (Pi, K1 with Simple AF)
configure_moonraker_updates() {
    local platform=$1

    # Skip on AD5M (typically no Mainsail/Fluidd web UI)
    if [ "$platform" = "ad5m" ]; then
        log_info "Skipping Moonraker update_manager on AD5M (typically no web UI)"
        return 0
    fi

    # Pi and K1 (Simple AF) both commonly use Mainsail/Fluidd
    log_info "Configuring Moonraker update_manager..."

    local conf
    conf=$(find_moonraker_conf)

    if [ -z "$conf" ]; then
        log_warn "Could not find moonraker.conf"
        log_warn "To enable web UI updates, manually add to your moonraker.conf:"
        echo ""
        generate_update_manager_config
        echo ""
        return 0
    fi

    if has_update_manager_section "$conf"; then
        log_info "update_manager section already exists in $conf"
        return 0
    fi

    add_update_manager_section "$conf"

    # Restart Moonraker to pick up the new configuration
    if command -v systemctl >/dev/null 2>&1 && $SUDO systemctl is-active --quiet moonraker 2>/dev/null; then
        log_info "Restarting Moonraker to apply configuration..."
        $SUDO systemctl restart moonraker || true
    elif [ -x "/etc/init.d/S56moonraker_service" ]; then
        # K1/Simple AF uses SysV init
        log_info "Restarting Moonraker to apply configuration..."
        if ! $SUDO /etc/init.d/S56moonraker_service restart 2>/dev/null; then
            log_warn "Could not restart Moonraker - you may need to restart it manually"
        fi
    fi
}

# Remove update_manager section from moonraker.conf
# Called during uninstallation
remove_update_manager_section() {
    local conf
    conf=$(find_moonraker_conf)

    if [ -z "$conf" ]; then
        return 0
    fi

    if ! has_update_manager_section "$conf"; then
        return 0
    fi

    log_info "Removing update_manager section from $conf..."

    # Create backup
    $SUDO cp "$conf" "${conf}.bak.helixscreen-uninstall" 2>/dev/null || true

    # Remove the section (from [update_manager helixscreen] to next section or EOF)
    # This uses awk to skip lines between [update_manager helixscreen] and the next [section]
    # Note: Need to run awk through sudo to handle permission on output file
    $SUDO sh -c "awk '
        /^\[update_manager helixscreen\]/ { skip=1; next }
        /^\[/ { skip=0 }
        !skip { print }
    ' \"$conf\" > \"${conf}.tmp\"" && $SUDO mv "${conf}.tmp" "$conf"

    # Also remove any "Added by HelixScreen" comment lines that precede it
    $SUDO sed -i '/# HelixScreen Update Manager/d' "$conf" 2>/dev/null || \
    $SUDO sed -i '' '/# HelixScreen Update Manager/d' "$conf" 2>/dev/null || true

    $SUDO sed -i '/# Added by HelixScreen installer/d' "$conf" 2>/dev/null || \
    $SUDO sed -i '' '/# Added by HelixScreen installer/d' "$conf" 2>/dev/null || true

    log_success "Removed update_manager section from $conf"
}

# ============================================
# Module: uninstall.sh
# ============================================

#
# Uninstall HelixScreen
# Args: platform (optional)
uninstall() {
    local platform=${1:-}

    log_info "Uninstalling HelixScreen..."

    # Detect init system first
    detect_init_system

    if [ "$INIT_SYSTEM" = "systemd" ]; then
        # Stop and disable systemd service
        $SUDO systemctl stop "$SERVICE_NAME" 2>/dev/null || true
        $SUDO systemctl disable "$SERVICE_NAME" 2>/dev/null || true
        $SUDO rm -f "/etc/systemd/system/${SERVICE_NAME}.service"
        $SUDO systemctl daemon-reload
    else
        # Stop and remove SysV init scripts (check all possible locations)
        # AD5M: S80/S90, K1: S99
        for init_script in /etc/init.d/S80helixscreen /etc/init.d/S90helixscreen /etc/init.d/S99helixscreen; do
            if [ -f "$init_script" ]; then
                log_info "Stopping and removing $init_script..."
                $SUDO "$init_script" stop 2>/dev/null || true
                $SUDO rm -f "$init_script"
            fi
        done
    fi

    # Kill any remaining processes (watchdog first to prevent crash dialog flash)
    if command -v killall >/dev/null 2>&1; then
        $SUDO killall helix-watchdog 2>/dev/null || true
        $SUDO killall helix-screen 2>/dev/null || true
        $SUDO killall helix-splash 2>/dev/null || true
    elif command -v pidof >/dev/null 2>&1; then
        for proc in helix-watchdog helix-screen helix-splash; do
            for pid in $(pidof "$proc" 2>/dev/null); do
                $SUDO kill "$pid" 2>/dev/null || true
            done
        done
    fi

    # Clean up PID files and log file
    $SUDO rm -f /var/run/helixscreen.pid 2>/dev/null || true
    $SUDO rm -f /var/run/helix-splash.pid 2>/dev/null || true
    $SUDO rm -f /tmp/helixscreen.log 2>/dev/null || true

    # Remove installation (check all possible locations)
    # AD5M: /opt/helixscreen, /root/printer_software/helixscreen
    # K1: /usr/data/helixscreen
    local removed_dir=""
    for install_dir in "/root/printer_software/helixscreen" "/opt/helixscreen" "/usr/data/helixscreen"; do
        if [ -d "$install_dir" ]; then
            $SUDO rm -rf "$install_dir"
            log_success "Removed ${install_dir}"
            removed_dir="$install_dir"
        fi
    done

    if [ -z "$removed_dir" ]; then
        log_warn "No HelixScreen installation found"
    fi

    # Re-enable the previous UI based on firmware
    log_info "Re-enabling previous screen UI..."
    local restored_ui=""
    local restored_xorg=""

    if [ "$AD5M_FIRMWARE" = "klipper_mod" ] || [ -f "/etc/init.d/S80klipperscreen" ]; then
        # Klipper Mod - restore Xorg and KlipperScreen
        if [ -f "/etc/init.d/S40xorg" ]; then
            $SUDO chmod +x "/etc/init.d/S40xorg" 2>/dev/null || true
            restored_xorg="Xorg (/etc/init.d/S40xorg)"
        fi
        if [ -f "/etc/init.d/S80klipperscreen" ]; then
            $SUDO chmod +x "/etc/init.d/S80klipperscreen" 2>/dev/null || true
            restored_ui="KlipperScreen (/etc/init.d/S80klipperscreen)"
        fi
    fi

    # Check for K1/Simple AF GuppyScreen
    if [ -z "$restored_ui" ] && [ -f "/etc/init.d/S99guppyscreen" ]; then
        $SUDO chmod +x "/etc/init.d/S99guppyscreen" 2>/dev/null || true
        restored_ui="GuppyScreen (/etc/init.d/S99guppyscreen)"
    fi

    if [ -z "$restored_ui" ]; then
        # Forge-X - restore GuppyScreen and stock UI settings
        # Restore ForgeX display mode to GUPPY (from HEADLESS or STOCK)
        if [ -f "/opt/config/mod_data/variables.cfg" ]; then
            if grep -q "display[[:space:]]*=[[:space:]]*'HEADLESS'" "/opt/config/mod_data/variables.cfg"; then
                log_info "Restoring ForgeX display mode to GUPPY..."
                $SUDO sed -i "s/display[[:space:]]*=[[:space:]]*'HEADLESS'/display = 'GUPPY'/" "/opt/config/mod_data/variables.cfg"
            elif grep -q "display[[:space:]]*=[[:space:]]*'STOCK'" "/opt/config/mod_data/variables.cfg"; then
                log_info "Restoring ForgeX display mode to GUPPY..."
                $SUDO sed -i "s/display[[:space:]]*=[[:space:]]*'STOCK'/display = 'GUPPY'/" "/opt/config/mod_data/variables.cfg"
            fi
        fi
        # Restore stock FlashForge UI in auto_run.sh
        restore_stock_firmware_ui || true
        # Remove HelixScreen patch from screen.sh
        unpatch_forgex_screen_sh || true
        # Re-enable GuppyScreen and tslib init scripts
        if [ -f "/opt/config/mod/.root/S80guppyscreen" ]; then
            $SUDO chmod +x "/opt/config/mod/.root/S80guppyscreen" 2>/dev/null || true
            restored_ui="GuppyScreen (/opt/config/mod/.root/S80guppyscreen)"
        fi
        if [ -f "/opt/config/mod/.root/S35tslib" ]; then
            $SUDO chmod +x "/opt/config/mod/.root/S35tslib" 2>/dev/null || true
        fi
    fi

    # Remove update_manager section from moonraker.conf (if present)
    if type remove_update_manager_section >/dev/null 2>&1; then
        remove_update_manager_section || true
    fi

    log_success "HelixScreen uninstalled"
    if [ -n "$restored_xorg" ]; then
        log_info "Re-enabled: $restored_xorg"
    fi
    if [ -n "$restored_ui" ]; then
        log_info "Re-enabled: $restored_ui"
        log_info "Reboot to start the previous UI"
    else
        log_info "Note: No previous UI found to restore"
    fi
}

# Clean up old installation completely (for --clean flag)
# Removes all files, config, and caches without backup
# Args: platform
clean_old_installation() {
    local platform=$1

    log_warn "=========================================="
    log_warn "  CLEAN INSTALL MODE"
    log_warn "=========================================="
    log_warn ""
    log_warn "This will PERMANENTLY DELETE:"
    log_warn "  - All HelixScreen files in ${INSTALL_DIR}"
    log_warn "  - Your configuration (helixconfig.json)"
    log_warn "  - Thumbnail cache files"
    log_warn ""

    # Interactive confirmation if stdin is a terminal
    if [ -t 0 ]; then
        printf "Are you sure? [y/N] "
        read -r response
        case "$response" in
            [yY][eE][sS]|[yY])
                ;;
            *)
                log_info "Clean install cancelled."
                exit 0
                ;;
        esac
    fi

    log_info "Cleaning old installation..."

    # Stop any running services
    stop_service

    # Remove installation directories (check all possible locations)
    # AD5M: /opt/helixscreen, /root/printer_software/helixscreen
    # K1: /usr/data/helixscreen
    for install_dir in "/root/printer_software/helixscreen" "/opt/helixscreen" "/usr/data/helixscreen"; do
        if [ -d "$install_dir" ]; then
            log_info "Removing $install_dir..."
            $SUDO rm -rf "$install_dir"
        fi
    done

    # Remove thumbnail caches (POSIX-compatible: no arrays)
    for cache_pattern in \
        "/root/.cache/helix/helix_thumbs" \
        "/home/*/.cache/helix/helix_thumbs" \
        "/tmp/helix_thumbs" \
        "/var/tmp/helix_thumbs"
    do
        for cache_dir in $cache_pattern; do
            if [ -d "$cache_dir" ] 2>/dev/null; then
                log_info "Removing cache: $cache_dir"
                $SUDO rm -rf "$cache_dir"
            fi
        done
    done

    # Remove init scripts (check all possible locations)
    # AD5M: S80/S90, K1: S99
    for init_script in /etc/init.d/S80helixscreen /etc/init.d/S90helixscreen /etc/init.d/S99helixscreen; do
        if [ -f "$init_script" ]; then
            log_info "Removing init script: $init_script"
            $SUDO rm -f "$init_script"
        fi
    done

    # Remove systemd service if present
    if [ -f "/etc/systemd/system/${SERVICE_NAME}.service" ]; then
        log_info "Removing systemd service..."
        $SUDO systemctl disable "$SERVICE_NAME" 2>/dev/null || true
        $SUDO rm -f "/etc/systemd/system/${SERVICE_NAME}.service"
        $SUDO systemctl daemon-reload 2>/dev/null || true
    fi

    log_success "Old installation cleaned"
    echo ""
}

# ============================================
# Main orchestration
# ============================================

# Set up error trap
trap 'error_handler $LINENO' ERR

# Print usage
usage() {
    echo "HelixScreen Installer"
    echo ""
    echo "Usage: $0 [options]"
    echo ""
    echo "Options:"
    echo "  --update       Update existing installation (preserves config)"
    echo "  --uninstall    Remove HelixScreen"
    echo "  --clean        Clean install: remove old installation completely,"
    echo "                 including config and caches (asks for confirmation)"
    echo "  --version VER  Install specific version (default: latest)"
    echo "  --help         Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0                    # Fresh install, latest version"
    echo "  $0 --update           # Update existing installation"
    echo "  $0 --clean            # Remove old install completely, then install"
    echo "  $0 --version v1.1.0   # Install specific version"
}

# Main installation flow
main() {
    update_mode=false
    uninstall_mode=false
    clean_mode=false
    version=""

    # Parse arguments
    while [ $# -gt 0 ]; do
        case $1 in
            --update)
                update_mode=true
                shift
                ;;
            --uninstall)
                uninstall_mode=true
                shift
                ;;
            --clean)
                clean_mode=true
                shift
                ;;
            --version)
                if [ -z "${2:-}" ]; then
                    log_error "--version requires a version argument"
                    exit 1
                fi
                version="$2"
                shift 2
                ;;
            --help|-h)
                usage
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done

    echo ""
    echo "${BOLD}========================================${NC}"
    echo "${BOLD}       HelixScreen Installer${NC}"
    echo "${BOLD}========================================${NC}"
    echo ""

    # Detect platform
    platform=$(detect_platform)
    log_info "Detected platform: ${BOLD}${platform}${NC}"

    if [ "$platform" = "unsupported" ]; then
        log_error "Unsupported platform: $(uname -m)"
        log_error "HelixScreen supports:"
        log_error "  - Raspberry Pi (aarch64/armv7l)"
        log_error "  - FlashForge Adventurer 5M (armv7l)"
        log_error "  - Creality K1 series with Simple AF"
        exit 1
    fi

    # For AD5M/K1, detect firmware variant and set appropriate paths
    local firmware=""
    if [ "$platform" = "ad5m" ]; then
        AD5M_FIRMWARE=$(detect_ad5m_firmware)
        firmware="$AD5M_FIRMWARE"
    elif [ "$platform" = "k1" ]; then
        K1_FIRMWARE=$(detect_k1_firmware)
        firmware="$K1_FIRMWARE"
    fi
    set_install_paths "$platform" "$firmware"

    # Check permissions
    check_permissions "$platform"

    # Handle uninstall (doesn't need all checks)
    if [ "$uninstall_mode" = true ]; then
        uninstall "$platform"
        exit 0
    fi

    # Pre-flight checks
    log_info "Running pre-flight checks..."
    check_requirements
    install_runtime_deps "$platform"
    check_disk_space "$platform"
    detect_init_system

    # Get version
    if [ -z "$version" ]; then
        version=$(get_latest_version)
    fi
    log_info "Target version: ${BOLD}${version}${NC}"

    # For ForgeX firmware, disable GuppyScreen in variables.cfg before stopping UIs
    if [ "$AD5M_FIRMWARE" = "forge_x" ]; then
        configure_forgex_display || true
        disable_stock_firmware_ui || true
        patch_forgex_screen_sh || true
    fi

    # Stop competing UIs
    stop_competing_uis

    # Clean old installation if requested
    if [ "$clean_mode" = true ]; then
        clean_old_installation "$platform"
    fi

    # Stop existing service if updating
    if [ "$update_mode" = true ]; then
        if [ ! -d "$INSTALL_DIR" ]; then
            log_warn "No existing installation found. Performing fresh install."
        fi
        stop_service
    fi

    # Download and install
    download_release "$version" "$platform"
    extract_release "$platform"
    install_service "$platform"

    # Configure Moonraker update_manager (Pi only - enables web UI updates)
    configure_moonraker_updates "$platform"

    # Start service
    start_service

    # Cleanup on success
    cleanup_on_success

    echo ""
    echo "${GREEN}${BOLD}========================================${NC}"
    echo "${GREEN}${BOLD}    Installation Complete!${NC}"
    echo "${GREEN}${BOLD}========================================${NC}"
    echo ""
    echo "HelixScreen ${version} installed to ${INSTALL_DIR}"
    echo ""
    echo "Useful commands:"
    if [ "$INIT_SYSTEM" = "systemd" ]; then
        echo "  systemctl status ${SERVICE_NAME}    # Check status"
        echo "  journalctl -u ${SERVICE_NAME} -f    # View logs"
        echo "  systemctl restart ${SERVICE_NAME}   # Restart"
    else
        echo "  ${INIT_SCRIPT_DEST} status   # Check status"
        echo "  cat /tmp/helixscreen.log            # View logs"
        echo "  ${INIT_SCRIPT_DEST} restart  # Restart"
    fi
    echo ""

    if [ "$platform" = "ad5m" ] || [ "$platform" = "k1" ]; then
        echo "Note: You may need to reboot for the display to update."
    fi
}

# Run main
main "$@"
