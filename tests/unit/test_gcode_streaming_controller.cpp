// SPDX-License-Identifier: GPL-3.0-or-later

#include "gcode_streaming_controller.h"

#include <chrono>
#include <cstdio>
#include <fstream>
#include <thread>
#include <unistd.h>

#include "../catch_amalgamated.hpp"

using namespace helix::gcode;

namespace {

// Helper to create a temporary G-code file with test content
class TempGCodeFile {
  public:
    explicit TempGCodeFile(const std::string& content) {
        // Create temp file
        char temp_path[] = "/tmp/gcode_test_XXXXXX";
        int fd = mkstemp(temp_path);
        if (fd == -1) {
            throw std::runtime_error("Failed to create temp file");
        }
        close(fd);
        path_ = temp_path;

        // Write content
        std::ofstream out(path_);
        out << content;
        out.close();
    }

    ~TempGCodeFile() {
        std::remove(path_.c_str());
    }

    const std::string& path() const {
        return path_;
    }

  private:
    std::string path_;
};

// Simple multi-layer G-code for testing
const std::string SIMPLE_3_LAYER_GCODE = R"(
; Generated for testing
G28 ; Home all axes
G1 Z0.3 F1000 ; Move to first layer height
G1 X10 Y10 E1 F1500 ; Extrusion move layer 0
G1 X20 Y10 E2
G1 X20 Y20 E3
G1 X10 Y20 E4

G1 Z0.5 F1000 ; Layer 1
G1 X10 Y10 E5 ; Extrusion move layer 1
G1 X20 Y10 E6
G1 X20 Y20 E7

G1 Z0.7 F1000 ; Layer 2
G1 X15 Y15 E8 ; Extrusion move layer 2
G1 X25 Y15 E9
)";

// More complex G-code with metadata
const std::string GCODE_WITH_METADATA = R"(
; generated by PrusaSlicer 2.6.0
; filament_type = PLA
; estimated printing time = 15m 30s
G28
G1 Z0.2 F1000
G1 X50 Y50 E1 F1500
G1 X100 Y50 E2

G1 Z0.4
G1 X50 Y100 E3
G1 X100 Y100 E4
)";

} // namespace

TEST_CASE("GCodeStreamingController basic operations", "[slow][gcode][streaming]") {
    TempGCodeFile temp_file(SIMPLE_3_LAYER_GCODE);

    SECTION("opens and closes files correctly") {
        GCodeStreamingController controller;

        REQUIRE_FALSE(controller.is_open());
        REQUIRE(controller.get_layer_count() == 0);

        REQUIRE(controller.open_file(temp_file.path()));
        REQUIRE(controller.is_open());
        REQUIRE(controller.get_layer_count() == 3);

        controller.close();
        REQUIRE_FALSE(controller.is_open());
        REQUIRE(controller.get_layer_count() == 0);
    }

    SECTION("reports correct source name") {
        GCodeStreamingController controller;
        controller.open_file(temp_file.path());

        REQUIRE(controller.get_source_name() == temp_file.path());
    }

    SECTION("returns nullptr for invalid file") {
        GCodeStreamingController controller;
        REQUIRE_FALSE(controller.open_file("/nonexistent/path/file.gcode"));
        REQUIRE_FALSE(controller.is_open());
    }
}

TEST_CASE("GCodeStreamingController layer access", "[slow][gcode][streaming]") {
    TempGCodeFile temp_file(SIMPLE_3_LAYER_GCODE);
    GCodeStreamingController controller;
    REQUIRE(controller.open_file(temp_file.path()));

    SECTION("get_layer_segments returns data") {
        auto* segments = controller.get_layer_segments(0);
        REQUIRE(segments != nullptr);
        REQUIRE(segments->size() > 0);

        // Verify it's extrusion data
        bool has_extrusion = false;
        for (const auto& seg : *segments) {
            if (seg.is_extrusion) {
                has_extrusion = true;
                break;
            }
        }
        REQUIRE(has_extrusion);
    }

    SECTION("get_layer_segments caches data") {
        // First access
        controller.get_layer_segments(1);
        REQUIRE(controller.is_layer_cached(1));

        // Second access should be cached
        auto* segments = controller.get_layer_segments(1);
        REQUIRE(segments != nullptr);
    }

    SECTION("returns nullptr for out of range layer") {
        auto* segments = controller.get_layer_segments(999);
        REQUIRE(segments == nullptr);
    }

    SECTION("get_layer_z returns correct heights") {
        float z0 = controller.get_layer_z(0);
        float z1 = controller.get_layer_z(1);
        float z2 = controller.get_layer_z(2);

        // Layers should be at increasing Z heights
        REQUIRE(z0 < z1);
        REQUIRE(z1 < z2);

        // Check approximate values from test G-code
        REQUIRE(z0 == Catch::Approx(0.3f).epsilon(0.1));
        REQUIRE(z1 == Catch::Approx(0.5f).epsilon(0.1));
        REQUIRE(z2 == Catch::Approx(0.7f).epsilon(0.1));
    }

    SECTION("find_layer_at_z works") {
        REQUIRE(controller.find_layer_at_z(0.3f) == 0);
        REQUIRE(controller.find_layer_at_z(0.5f) == 1);
        REQUIRE(controller.find_layer_at_z(0.7f) == 2);

        // Approximate matches
        REQUIRE(controller.find_layer_at_z(0.35f) == 0);
        REQUIRE(controller.find_layer_at_z(0.45f) == 1);
    }
}

TEST_CASE("GCodeStreamingController cache management", "[slow][gcode][streaming]") {
    TempGCodeFile temp_file(SIMPLE_3_LAYER_GCODE);

    SECTION("cache budget can be set") {
        GCodeStreamingController controller(4 * 1024 * 1024); // 4MB
        controller.open_file(temp_file.path());

        REQUIRE(controller.get_cache_budget() == 4 * 1024 * 1024);

        controller.set_cache_budget(8 * 1024 * 1024);
        REQUIRE(controller.get_cache_budget() == 8 * 1024 * 1024);
    }

    SECTION("minimum budget is enforced") {
        GCodeStreamingController controller;
        controller.set_cache_budget(100); // Too small

        REQUIRE(controller.get_cache_budget() >= GCodeStreamingController::MIN_CACHE_BUDGET);
    }

    SECTION("clear_cache works") {
        GCodeStreamingController controller;
        controller.open_file(temp_file.path());

        controller.get_layer_segments(0);
        controller.get_layer_segments(1);
        REQUIRE(controller.get_cache_memory_usage() > 0);

        controller.clear_cache();
        REQUIRE(controller.get_cache_memory_usage() == 0);
    }

    SECTION("cache hit rate is tracked") {
        GCodeStreamingController controller;
        controller.open_file(temp_file.path());

        // First access - miss
        controller.get_layer_segments(0);
        // Second access - hit
        controller.get_layer_segments(0);
        // Third access - hit
        controller.get_layer_segments(0);

        // Should be 2/3 = 0.667
        REQUIRE(controller.get_cache_hit_rate() > 0.5f);
    }
}

TEST_CASE("GCodeStreamingController prefetch", "[slow][gcode][streaming]") {
    // Create a larger file with more layers
    std::string large_gcode = "; Test file\nG28\n";
    for (int layer = 0; layer < 20; ++layer) {
        float z = 0.2f + layer * 0.2f;
        large_gcode += "G1 Z" + std::to_string(z) + " F1000\n";
        large_gcode +=
            "G1 X" + std::to_string(10 + layer) + " Y10 E" + std::to_string(layer + 1) + " F1500\n";
    }

    TempGCodeFile temp_file(large_gcode);
    GCodeStreamingController controller;
    REQUIRE(controller.open_file(temp_file.path()));

    SECTION("prefetch loads nearby layers") {
        // Clear any auto-prefetched layers
        controller.clear_cache();

        // Access layer 10, which should prefetch layers 7-13
        controller.get_layer_segments(10);

        // Nearby layers should be cached
        REQUIRE(controller.is_layer_cached(10));
        REQUIRE(controller.is_layer_cached(9));
        REQUIRE(controller.is_layer_cached(11));

        // Distant layers should not be cached
        REQUIRE_FALSE(controller.is_layer_cached(0));
        REQUIRE_FALSE(controller.is_layer_cached(19));
    }

    SECTION("explicit prefetch works") {
        controller.clear_cache();
        controller.prefetch_around(5, 2);

        // Layers 3-7 should be cached
        for (size_t i = 3; i <= 7; ++i) {
            REQUIRE(controller.is_layer_cached(i));
        }
    }
}

TEST_CASE("GCodeStreamingController index stats", "[slow][gcode][streaming]") {
    TempGCodeFile temp_file(SIMPLE_3_LAYER_GCODE);
    GCodeStreamingController controller;

    SECTION("stats available after open") {
        REQUIRE(controller.open_file(temp_file.path()));

        const auto& stats = controller.get_index_stats();
        REQUIRE(stats.total_layers == 3);
        REQUIRE(stats.total_lines > 0);
        REQUIRE(stats.total_bytes > 0);
        REQUIRE(stats.min_z > 0.0f);
        REQUIRE(stats.max_z > stats.min_z);
        REQUIRE(stats.extrusion_moves > 0);
    }

    SECTION("file size is reported") {
        controller.open_file(temp_file.path());
        REQUIRE(controller.get_file_size() > 0);
    }
}

TEST_CASE("GCodeStreamingController async operations", "[slow][gcode][streaming]") {
    TempGCodeFile temp_file(SIMPLE_3_LAYER_GCODE);

    SECTION("async open completes") {
        GCodeStreamingController controller;
        std::atomic<bool> completed{false};
        std::atomic<bool> success{false};

        controller.open_file_async(temp_file.path(), [&](bool result) {
            success.store(result);
            completed.store(true);
        });

        // Wait for completion (with timeout)
        auto start = std::chrono::steady_clock::now();
        while (!completed.load()) {
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
            auto elapsed = std::chrono::steady_clock::now() - start;
            if (elapsed > std::chrono::seconds(5)) {
                FAIL("Async open timed out");
                break;
            }
        }

        REQUIRE(success.load());
        REQUIRE(controller.is_open());
        REQUIRE(controller.get_layer_count() == 3);
    }

    SECTION("is_indexing returns correct state") {
        GCodeStreamingController controller;

        REQUIRE_FALSE(controller.is_indexing());

        // Start async open
        controller.open_file_async(temp_file.path());

        // May or may not still be indexing depending on timing
        // Just verify it doesn't crash
        bool was_indexing = controller.is_indexing();
        (void)was_indexing;

        // Wait for completion
        while (controller.is_indexing()) {
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }

        REQUIRE_FALSE(controller.is_indexing());
    }
}

TEST_CASE("GCodeStreamingController memory pressure", "[slow][gcode][streaming]") {
    TempGCodeFile temp_file(SIMPLE_3_LAYER_GCODE);
    GCodeStreamingController controller;
    controller.open_file(temp_file.path());

    SECTION("respond_to_memory_pressure reduces cache") {
        // Fill cache
        controller.get_layer_segments(0);
        controller.get_layer_segments(1);
        controller.get_layer_segments(2);

        size_t before = controller.get_cache_memory_usage();
        REQUIRE(before > 0);

        controller.respond_to_memory_pressure();

        // Cache should be reduced (though may still have some entries)
        // Just verify it doesn't crash
        REQUIRE(controller.get_cache_memory_usage() >= 0);
    }

    SECTION("adaptive cache can be enabled") {
        controller.set_adaptive_cache(true);
        // Just verify it doesn't crash
        controller.get_layer_segments(0);
        REQUIRE(controller.is_open());
    }
}

TEST_CASE("GCodeStreamingController error handling", "[slow][gcode][streaming]") {
    SECTION("handles close when not open") {
        GCodeStreamingController controller;
        controller.close(); // Should not crash
        REQUIRE_FALSE(controller.is_open());
    }

    SECTION("handles repeated open") {
        TempGCodeFile temp_file(SIMPLE_3_LAYER_GCODE);
        GCodeStreamingController controller;

        controller.open_file(temp_file.path());
        REQUIRE(controller.is_open());

        // Open again should close first and reopen
        controller.open_file(temp_file.path());
        REQUIRE(controller.is_open());
    }

    SECTION("empty stats when not open") {
        GCodeStreamingController controller;
        const auto& stats = controller.get_index_stats();

        REQUIRE(stats.total_layers == 0);
        REQUIRE(stats.total_bytes == 0);
    }
}

// =============================================================================
// BackgroundGhostBuilder Tests
// =============================================================================

TEST_CASE("BackgroundGhostBuilder basic operations", "[slow][gcode][streaming][ghost]") {
    TempGCodeFile temp_file(SIMPLE_3_LAYER_GCODE);
    GCodeStreamingController controller;
    REQUIRE(controller.open_file(temp_file.path()));

    SECTION("initial state is correct") {
        BackgroundGhostBuilder builder;

        REQUIRE_FALSE(builder.is_running());
        REQUIRE_FALSE(builder.is_complete());
        REQUIRE(builder.get_progress() == 0.0f);
        REQUIRE(builder.layers_rendered() == 0);
    }

    SECTION("starts and completes with callback") {
        BackgroundGhostBuilder builder;
        std::atomic<size_t> layers_rendered{0};
        std::atomic<size_t> segments_received{0};

        builder.start(&controller, [&](size_t layer_idx, const std::vector<ToolpathSegment>& segs) {
            layers_rendered++;
            segments_received += segs.size();
        });

        // Wait for completion
        auto start = std::chrono::steady_clock::now();
        while (!builder.is_complete()) {
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
            auto elapsed = std::chrono::steady_clock::now() - start;
            if (elapsed > std::chrono::seconds(5)) {
                FAIL("Ghost builder timed out");
                break;
            }
        }

        REQUIRE(builder.is_complete());
        REQUIRE_FALSE(builder.is_running());
        REQUIRE(builder.get_progress() == 1.0f);
        REQUIRE(builder.layers_rendered() == 3);
        REQUIRE(layers_rendered.load() == 3);
        REQUIRE(segments_received.load() > 0);
    }

    SECTION("reports progress during build") {
        // Create a larger file for more measurable progress
        std::string large_gcode = "; Test file\nG28\n";
        for (int layer = 0; layer < 50; ++layer) {
            float z = 0.2f + layer * 0.2f;
            large_gcode += "G1 Z" + std::to_string(z) + " F1000\n";
            large_gcode += "G1 X" + std::to_string(10 + layer) + " Y10 E" +
                           std::to_string(layer + 1) + " F1500\n";
        }
        TempGCodeFile large_file(large_gcode);

        GCodeStreamingController large_controller;
        REQUIRE(large_controller.open_file(large_file.path()));

        BackgroundGhostBuilder builder;
        std::vector<float> progress_samples;
        std::mutex samples_mutex;

        builder.start(&large_controller,
                      [&](size_t /*layer_idx*/, const std::vector<ToolpathSegment>& /*segs*/) {
                          // Record progress at each layer
                          float p = builder.get_progress();
                          std::lock_guard<std::mutex> lock(samples_mutex);
                          progress_samples.push_back(p);
                      });

        // Wait for completion
        auto start = std::chrono::steady_clock::now();
        while (!builder.is_complete()) {
            std::this_thread::sleep_for(std::chrono::milliseconds(5));
            auto elapsed = std::chrono::steady_clock::now() - start;
            if (elapsed > std::chrono::seconds(10)) {
                FAIL("Ghost builder timed out");
                break;
            }
        }

        REQUIRE(builder.is_complete());
        REQUIRE(builder.total_layers() == 50);

        // Verify progress increased monotonically
        std::lock_guard<std::mutex> lock(samples_mutex);
        REQUIRE(progress_samples.size() > 0);
        for (size_t i = 1; i < progress_samples.size(); ++i) {
            REQUIRE(progress_samples[i] >= progress_samples[i - 1]);
        }
    }
}

TEST_CASE("BackgroundGhostBuilder cancellation", "[slow][gcode][streaming][ghost]") {
    // Create larger file so we have time to cancel
    std::string large_gcode = "; Test file\nG28\n";
    for (int layer = 0; layer < 100; ++layer) {
        float z = 0.2f + layer * 0.2f;
        large_gcode += "G1 Z" + std::to_string(z) + " F1000\n";
        for (int seg = 0; seg < 10; ++seg) {
            large_gcode += "G1 X" + std::to_string(10 + seg) + " Y" + std::to_string(10 + seg) +
                           " E" + std::to_string(layer * 10 + seg + 1) + " F1500\n";
        }
    }
    TempGCodeFile temp_file(large_gcode);

    GCodeStreamingController controller;
    REQUIRE(controller.open_file(temp_file.path()));

    SECTION("cancel stops the build") {
        BackgroundGhostBuilder builder;
        std::atomic<size_t> layers_rendered{0};

        builder.start(&controller, [&](size_t /*layer_idx*/, const std::vector<ToolpathSegment>&) {
            layers_rendered++;
            // Add a small delay to make cancellation easier
            std::this_thread::sleep_for(std::chrono::milliseconds(5));
        });

        // Let it run briefly
        std::this_thread::sleep_for(std::chrono::milliseconds(50));

        // Cancel
        builder.cancel();

        // Should have stopped before completing all layers
        REQUIRE_FALSE(builder.is_running());
        REQUIRE_FALSE(builder.is_complete()); // Was cancelled, not completed
        REQUIRE(layers_rendered.load() < 100);
    }

    SECTION("cancel is idempotent") {
        BackgroundGhostBuilder builder;

        // Cancel without starting - should be safe
        builder.cancel();
        builder.cancel();
        REQUIRE_FALSE(builder.is_running());
    }

    SECTION("destructor cancels automatically") {
        std::atomic<bool> callback_called{false};
        {
            BackgroundGhostBuilder builder;
            builder.start(&controller, [&](size_t, const std::vector<ToolpathSegment>&) {
                callback_called = true;
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
            });
            // Let it start
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
            // Destructor should cancel and join
        }
        // If we get here without hanging, destructor worked correctly
        REQUIRE(true);
    }
}

TEST_CASE("BackgroundGhostBuilder UI yielding", "[slow][gcode][streaming][ghost]") {
    TempGCodeFile temp_file(SIMPLE_3_LAYER_GCODE);
    GCodeStreamingController controller;
    REQUIRE(controller.open_file(temp_file.path()));

    SECTION("notify_user_request can be called during build") {
        BackgroundGhostBuilder builder;

        builder.start(&controller, [&](size_t, const std::vector<ToolpathSegment>&) {
            // Simulate user navigation during build
            builder.notify_user_request();
        });

        // Wait for completion
        auto start = std::chrono::steady_clock::now();
        while (!builder.is_complete()) {
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
            auto elapsed = std::chrono::steady_clock::now() - start;
            if (elapsed > std::chrono::seconds(5)) {
                FAIL("Ghost builder timed out");
                break;
            }
        }

        REQUIRE(builder.is_complete());
    }
}

TEST_CASE("BackgroundGhostBuilder error handling", "[slow][gcode][streaming][ghost]") {
    SECTION("start with closed controller does nothing") {
        GCodeStreamingController controller;
        BackgroundGhostBuilder builder;

        // Controller is not open
        builder.start(&controller, [](size_t, const std::vector<ToolpathSegment>&) {});

        // Should not start
        REQUIRE_FALSE(builder.is_running());
        REQUIRE_FALSE(builder.is_complete());
    }

    SECTION("start with null controller does nothing") {
        BackgroundGhostBuilder builder;

        builder.start(nullptr, [](size_t, const std::vector<ToolpathSegment>&) {});

        REQUIRE_FALSE(builder.is_running());
    }

    SECTION("restart cancels previous build") {
        TempGCodeFile temp_file(SIMPLE_3_LAYER_GCODE);
        GCodeStreamingController controller;
        REQUIRE(controller.open_file(temp_file.path()));

        BackgroundGhostBuilder builder;
        std::atomic<int> callback_count{0};

        // Start first build
        builder.start(&controller, [&](size_t, const std::vector<ToolpathSegment>&) {
            callback_count++;
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
        });

        // Start second build immediately (should cancel first)
        builder.start(&controller,
                      [&](size_t, const std::vector<ToolpathSegment>&) { callback_count++; });

        // Wait for second build to complete
        auto start = std::chrono::steady_clock::now();
        while (!builder.is_complete()) {
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
            auto elapsed = std::chrono::steady_clock::now() - start;
            if (elapsed > std::chrono::seconds(5)) {
                FAIL("Ghost builder timed out");
                break;
            }
        }

        REQUIRE(builder.is_complete());
        // Should have rendered all layers from second build
        REQUIRE(builder.layers_rendered() == 3);
    }
}
